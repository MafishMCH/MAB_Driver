   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "motor_lib.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .text.MOTOR_LIB_MinMaxLimiter,"ax",%progbits
  20              	 .align 2
  21              	 .thumb
  22              	 .thumb_func
  24              	MOTOR_LIB_MinMaxLimiter:
  25              	.LFB128:
  26              	 .file 1 "../Dave/Generated/MOTOR_LIB/motor_lib.h"
   1:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
   2:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * @file motor_lib.h
   3:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * @date 2015-10-08
   4:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *
   5:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * NOTE:
   6:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * This file is generated by DAVE. Any manual modification done to this file will be lost when the 
   7:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *
   8:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * @cond
   9:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  **************************************************************************************************
  10:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * MOTOR_LIB v4.0.8 - Provides common motor control library API's.
  11:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *
  12:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * Copyright (c) 2015-2017, Infineon Technologies AG
  13:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * All rights reserved.
  14:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *
  15:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  16:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * following conditions are met:
  17:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *
  18:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *   Redistributions of source code must retain the above copyright notice, this list of conditions
  19:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *   disclaimer.
  20:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *
  21:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *   Redistributions in binary form must reproduce the above copyright notice, this list of conditi
  22:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *   following disclaimer in the documentation and/or other materials provided with the distributio
  23:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *
  24:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *   Neither the name of the copyright holders nor the names of its contributors may be used to end
  25:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *   products derived from this software without specific prior written permission.
  26:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *
  27:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  28:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  29:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  30:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  31:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  32:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  33:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *
  35:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  36:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * with Infineon Technologies AG (dave@infineon.com).
  37:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  **************************************************************************************************
  38:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *
  39:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * Change History
  40:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * --------------
  41:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *
  42:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * 2015-02-20:
  43:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *     - Initial version
  44:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *
  45:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * 2015-06-20:
  46:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *     - Vector magnitude calculation API's are added
  47:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *
  48:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * @endcond
  49:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *
  50:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  */
  51:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
  52:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #ifndef MOTOR_LIB_H_
  53:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_H_
  54:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**************************************************************************************************
  55:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * HEADER FILES
  56:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  **************************************************************************************************
  57:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #include <xmc_common.h>
  58:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #include <DAVE_common.h>
  59:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #include "motor_lib_conf.h"
  60:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
  61:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #if (!((XMC_LIB_MAJOR_VERSION == 2U) && \
  62:../Dave/Generated/MOTOR_LIB/motor_lib.h ****        (XMC_LIB_MINOR_VERSION >= 0U) && \
  63:../Dave/Generated/MOTOR_LIB/motor_lib.h ****        (XMC_LIB_PATCH_VERSION >= 0U)))
  64:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #error "MOTOR_LIB requires XMC Peripheral Library v2.0.0 or higher"
  65:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #endif
  66:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**************************************************************************************************
  67:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * MACROS
  68:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  **************************************************************************************************
  69:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
  70:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
  71:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @ingroup MOTOR_LIB_constants
  72:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @{
  73:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
  74:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
  75:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**This is Inverse of Square root of 3 (1/sqrt(3)*2^15)*/
  76:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_INVSQRT3 (0x49E6)
  77:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
  78:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**This is Angle Scaling - Convert 24 bit to 16 bit*/
  79:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_ANGLESCALE  (0xFF)
  80:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_ANGLESCALE_SHIFT  (0x8U)
  81:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
  82:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**This is Amplitude Scaling - Convert 24 bit to 16 bit*/
  83:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_AMPSCALE  (0xFF)
  84:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
  85:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**This is to extract CORDZ data */
  86:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_CORDZ_DATA_POSSCALE (0xFF)
  87:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_CORDZ_DATA_POSSCALE_SHIFT (0x8U)
  88:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
  89:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**This is to extract CORRX Result data */
  90:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_CORRX_RESULT_POSSCALE (0x8U)
  91:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
  92:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**This is PI Controller KP Values Scaling*/
  93:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_PI_KPSCALE  (0x1FF)
  94:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_PI_KPSCALE_SHIFT  (0x09U)
  95:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
  96:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**This is Inverse of kCordic value (2^16/(1.64676 * 2^8)) */
  97:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_INV_KCORDIC (155)
  98:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /*Divided by 2 is done by CORIDC operation*/
  99:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_KCORDIC_SCALE (0xFF/2)
 100:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**This is Inverse of kCordic value in hyperbolic mode(2^16/(0.828159360960 * 2^8)) */
 101:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_INV_KCORDIC_HYPERBOLIC (308)
 102:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**This is kCordic value in hyperbolic mode(0.828159360960*2^8) */
 103:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_K_Hyperbolic (0.828159360960 * 0xFF)
 104:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 105:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /** This is CORDIC scale value after considering magnitude pre-scalar value. MOTOR_LIB_KCORDIC_SCAL
 106:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_MPS (0xFF)
 107:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_MPS_DIV2 (2U)
 108:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 109:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /** This is (2^16 -1)value used for scaling operation */
 110:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_2POW16 (0xFFFF)
 111:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_2POW23 (0x7FFFFF)
 112:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_SHIFT8 (8U)
 113:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 114:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**This is PI Controller KI Values SCaling*/
 115:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_PI_KISCALE       (0x7FFF)
 116:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_PI_KISCALE_SHIFT (0x0FU)
 117:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 118:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 119:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @}
 120:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 121:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 122:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 123:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 124:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #if !defined (MATH)
 125:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 126:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @ingroup MOTOR_LIB_constants
 127:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @{
 128:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 129:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**This is CORIDC K values used in SW CORIDC*/
 130:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_CORDIC_K             (1304065792U)
 131:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 132:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**This is CORIDC Iteration, maximum values is 23*/
 133:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #define MOTOR_LIB_CORDIC_ITERATIONS    (15U)
 134:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 135:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 136:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @}
 137:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 138:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 139:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**************************************************************************************************
 140:../Dave/Generated/MOTOR_LIB/motor_lib.h **** * ENUMS
 141:../Dave/Generated/MOTOR_LIB/motor_lib.h **** ***************************************************************************************************
 142:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 143:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 144:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @ingroup MOTOR_LIB_enumerations
 145:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @{
 146:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 147:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 148:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * This enumerates magnitude prescaler value for calculated value of X & Y
 149:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  */
 150:../Dave/Generated/MOTOR_LIB/motor_lib.h **** typedef enum MOTOR_LIB_CON_MPS
 151:../Dave/Generated/MOTOR_LIB/motor_lib.h **** {
 152:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  /**
 153:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * After the last iteration of calculation the X & Y values are divided by 1
 154:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 155:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_MPS_DIVBY1 = 0x00U,
 156:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  /**
 157:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * After the last iteration of calculation the X & Y values are divided by 2
 158:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 159:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_MPS_DIVBY2 = 0x01U,
 160:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  /**
 161:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * After the last iteration of calculation the X & Y values are divided by 4
 162:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 163:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_MPS_DIVBY4 = 0x02U
 164:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 165:../Dave/Generated/MOTOR_LIB/motor_lib.h **** } MOTOR_LIB_CON_MPS_t;
 166:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 167:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @}
 168:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 169:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #endif
 170:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 171:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #if defined (MATH)
 172:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 173:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @ingroup MOTOR_LIB_enumerations
 174:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @{
 175:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 176:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 177:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * This enumerates control to Keep or Clear the last X result as initial data
 178:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * for next calculation
 179:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  */
 180:../Dave/Generated/MOTOR_LIB/motor_lib.h **** typedef enum MOTOR_LIB_STATC_KEEPX
 181:../Dave/Generated/MOTOR_LIB/motor_lib.h **** {
 182:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 183:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This clears last X Result for a New Calculation
 184:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 185:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_CLEAR_KEEPX = 0x00U,
 186:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 187:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This keeps last X Result as Initial Data for a New Calculation
 188:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 189:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_SET_KEEPX = 0x20U
 190:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 191:../Dave/Generated/MOTOR_LIB/motor_lib.h **** } MOTOR_LIB_STATC_KEEPX_t;
 192:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 193:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * This enumerates control to Keep or Clear the last Y result as initial data
 194:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * for next calculation
 195:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  */
 196:../Dave/Generated/MOTOR_LIB/motor_lib.h **** typedef enum MOTOR_LIB_STATC_KEEPY
 197:../Dave/Generated/MOTOR_LIB/motor_lib.h **** {
 198:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 199:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This clears last Y Result for a New Calculation
 200:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 201:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_CLEAR_KEEPY = 0x00U,
 202:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 203:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This keeps last Y Result as Initial Data for a New Calculation
 204:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 205:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_SET_KEEPY = 0x40U
 206:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 207:../Dave/Generated/MOTOR_LIB/motor_lib.h **** } MOTOR_LIB_STATC_KEEPY_t;
 208:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 209:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 210:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * This enumerates control to Keep or Clear the last Z result as initial data
 211:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * for next calculation
 212:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  */
 213:../Dave/Generated/MOTOR_LIB/motor_lib.h **** typedef enum MOTOR_LIB_STATC_KEEPZ
 214:../Dave/Generated/MOTOR_LIB/motor_lib.h **** {
 215:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 216:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This clears last Z Result for a New Calculation
 217:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 218:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_CLEAR_KEEPZ = 0x00U,
 219:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 220:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This keeps last Z Result as Initial Data for a New Calculation
 221:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 222:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_SET_KEEPZ = 0x80U
 223:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 224:../Dave/Generated/MOTOR_LIB/motor_lib.h **** } MOTOR_LIB_STATC_KEEPZ_t;
 225:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 226:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * This enumerates different modes for CORDIC operating modes
 227:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  */
 228:../Dave/Generated/MOTOR_LIB/motor_lib.h **** typedef enum MOTOR_LIB_CON_MODE
 229:../Dave/Generated/MOTOR_LIB/motor_lib.h **** {
 230:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 231:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This sets CORDIC to Linear Operating Mode
 232:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 233:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_LINEAR_MODE = 0x0U,
 234:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 235:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This sets CORDIC to Circular Operating Mode
 236:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 237:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_CIRCULAR_MODE = 0x2U,
 238:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 239:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This sets CORDIC to Hyperbolic Operating Mode
 240:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 241:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_HYPERBOLIC_MODE = 0x6U
 242:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 243:../Dave/Generated/MOTOR_LIB/motor_lib.h **** } MOTOR_LIB_CON_MODE_t;
 244:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 245:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 246:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * This enumerates CORDIC Rotation Vectoring Selection
 247:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  */
 248:../Dave/Generated/MOTOR_LIB/motor_lib.h **** typedef enum MOTOR_LIB_CON_ROTVEC
 249:../Dave/Generated/MOTOR_LIB/motor_lib.h **** {
 250:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 251:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This sets CORDIC to Vectoring Mode
 252:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 253:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_VECTORING_MODE = 0x0U,
 254:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 255:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This sets CORDIC to Rotation Mode
 256:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 257:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_ROTATION_MODE = 0x8U
 258:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 259:../Dave/Generated/MOTOR_LIB/motor_lib.h **** } MOTOR_LIB_CON_ROTVEC_t;
 260:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 261:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 262:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * This enumerates different modes for starting CORDIC operation
 263:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  */
 264:../Dave/Generated/MOTOR_LIB/motor_lib.h **** typedef enum MOTOR_LIB_CON_STMODE
 265:../Dave/Generated/MOTOR_LIB/motor_lib.h **** {
 266:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 267:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * Auto start of calculation after write access to X parameter data register
 268:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 269:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_CORDIC_AUTO_START = 0x00U,
 270:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 271:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * Start calculation only after bit ST is set
 272:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 273:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_CORDIC_ST_START = 0x10U
 274:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 275:../Dave/Generated/MOTOR_LIB/motor_lib.h **** } MOTOR_LIB_CON_STMODE_t;
 276:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 277:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 278:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * This enumerates 'X result register' data format in circular vectoring mode.
 279:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  */
 280:../Dave/Generated/MOTOR_LIB/motor_lib.h **** typedef enum MOTOR_LIB_CON_XUSIGN
 281:../Dave/Generated/MOTOR_LIB/motor_lib.h **** {
 282:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 283:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This sets X result data format to Signed (twos complement), when read
 284:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 285:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_SIGNED_X_RESULT = 0x00U,
 286:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 287:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This sets X result data format to Unsigned, when read
 288:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 289:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_UNSIGNED_X_RESULT = 0x20U
 290:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 291:../Dave/Generated/MOTOR_LIB/motor_lib.h **** }MOTOR_LIB_CON_XUSIGN_t;
 292:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 293:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 294:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * This enumerates magnitude prescaler value for calculated value of X & Y
 295:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  */
 296:../Dave/Generated/MOTOR_LIB/motor_lib.h **** typedef enum MOTOR_LIB_CON_MPS
 297:../Dave/Generated/MOTOR_LIB/motor_lib.h **** {
 298:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 299:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * After the last iteration of calculation the X & Y values are divided by 1
 300:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 301:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_MPS_DIVBY1 = 0x00U,
 302:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 303:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * After the last iteration of calculation the X & Y values are divided by 2
 304:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 305:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_MPS_DIVBY2 = 0x40U,
 306:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 307:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * After the last iteration of calculation the X & Y values are divided by 4
 308:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 309:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_MPS_DIVBY4 = 0x80U
 310:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 311:../Dave/Generated/MOTOR_LIB/motor_lib.h **** }MOTOR_LIB_CON_MPS_t;
 312:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 313:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #endif
 314:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 315:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 316:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @}
 317:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 318:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 319:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 320:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @ingroup MOTOR_LIB_datastructures
 321:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @{
 322:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 323:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**************************************************************************************************
 324:../Dave/Generated/MOTOR_LIB/motor_lib.h **** * DATA STRUCTURES
 325:../Dave/Generated/MOTOR_LIB/motor_lib.h **** ***************************************************************************************************
 326:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 327:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * This structure holds the values of PI parameters.
 328:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  */
 329:../Dave/Generated/MOTOR_LIB/motor_lib.h **** typedef struct MOTOR_LIB_PIHandle
 330:../Dave/Generated/MOTOR_LIB/motor_lib.h **** {
 331:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 332:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This is the Kp value
 333:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 334:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   uint32_t  kp;
 335:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  /**
 336:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * This is the Ki value
 337:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 338:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   uint32_t  ki;
 339:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  /**
 340:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * This is the buffer
 341:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 342:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   int32_t  i_buf;
 343:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 344:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * Maximum limit for buffer
 345:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 346:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   const int32_t  y_imax;
 347:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 348:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * Minimum limit for buffer
 349:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 350:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   const int32_t  y_imin;
 351:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 352:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * Maximum limit for PI controller output
 353:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 354:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   const int16_t  y_max;
 355:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 356:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * Minimum limit for PI controller output
 357:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 358:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   const int16_t  y_min;
 359:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 360:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This is the required output value for PI controller
 361:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 362:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   int16_t pi_out_val;
 363:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 364:../Dave/Generated/MOTOR_LIB/motor_lib.h **** } MOTOR_LIB_PIHandle_t;
 365:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 366:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 367:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 368:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * This structure holds the values of PT1 filter parameters.
 369:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  */
 370:../Dave/Generated/MOTOR_LIB/motor_lib.h **** typedef struct MOTOR_LIB_PT1Handle
 371:../Dave/Generated/MOTOR_LIB/motor_lib.h **** {
 372:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 373:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * Filter constant
 374:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 375:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   int32_t  z1;
 376:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 377:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * Filter constant
 378:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 379:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   int32_t  z2;
 380:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 381:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * Maximum limit of PT1 buffer
 382:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 383:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   const int32_t  y_max;
 384:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 385:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * Minimum limit of PT1 buffer
 386:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 387:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   const int32_t  y_min;
 388:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 389:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This is the integral buffer of pt1 filter
 390:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 391:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   int32_t  pt1_buf;
 392:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 393:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This is PT1 filter output.
 394:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 395:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   int32_t  pt1_out_val;
 396:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 397:../Dave/Generated/MOTOR_LIB/motor_lib.h **** } MOTOR_LIB_PT1Handle_t;
 398:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 399:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 400:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * This structure holds the values of Feed Forward controller parameters.
 401:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  */
 402:../Dave/Generated/MOTOR_LIB/motor_lib.h **** typedef struct MOTOR_LIB_FeedForwardHandle
 403:../Dave/Generated/MOTOR_LIB/motor_lib.h **** {
 404:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 405:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * PT1 filter
 406:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 407:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   MOTOR_LIB_PT1Handle_t *pt1_filter_ptr;
 408:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 409:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * FeedForward output
 410:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 411:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   int32_t feedforward_out_val;
 412:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 413:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This is the integral buffer of pt1 filter
 414:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 415:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   int32_t  antinoise_filter_buffer;
 416:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 417:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This is to store FeedForward output values based on dead time configuration
 418:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 419:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   int32_t  dead_time_buffer;
 420:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 421:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This is the differential operation buffer
 422:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 423:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   int32_t  differential_buffer;
 424:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 425:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * Maximum limit for Feed Forward controller output
 426:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 427:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   int32_t  y_max;
 428:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 429:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * Minimum limit for Feed Forward controller output
 430:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 431:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   int32_t  y_min;
 432:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 433:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This is the gain value
 434:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 435:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   uint16_t  feedforward_gain;
 436:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 437:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This is the differential gain value
 438:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 439:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   uint16_t  differential_gain;
 440:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 441:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 442:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * This is dead band for i/p to avoid LSB flickering
 443:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 444:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   uint16_t  dead_band;
 445:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 446:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   /**
 447:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * Dead time enable/disable control
 448:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    * DeadTime - 1 -Enable delay of 1 cycle
 449:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    *          - 0 -Disable delay
 450:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    */
 451:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    uint8_t  dead_time_enable;
 452:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 453:../Dave/Generated/MOTOR_LIB/motor_lib.h **** } MOTOR_LIB_FeedForwardHandle_t;
 454:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 455:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 456:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * @}
 457:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  */
 458:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #ifdef __cplusplus
 459:../Dave/Generated/MOTOR_LIB/motor_lib.h **** extern "C" {
 460:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #endif
 461:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 462:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * @ingroup MOTOR_LIB_apidoc
 463:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * @{
 464:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  */
 465:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**************************************************************************************************
 466:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * API Prototypes
 467:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  **************************************************************************************************
 468:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #if defined (MATH)
 469:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 470:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @brief Enables HW CORDIC in case of XMC13 device.
 471:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param None
 472:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @return None
 473:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 474:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * \par<b>Description</b><br>
 475:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * This function enables HW CORDIC in case of XMC13 device.
 476:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 477:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * \par<b>Note</b><br>
 478:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * This API should be called before using any CORDIC related API's.
 479:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 480:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Example Usage:
 481:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @code
 482:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    #include <DAVE.h>
 483:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    int main (void)
 484:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    {
 485:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      DAVE_STATUS_t status;
 486:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      status = DAVE_Init();
 487:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      MOTOR_LIB_CordicEnable();
 488:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      while(1);
 489:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      return 0;
 490:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    }
 491:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @endcode
 492:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 493:../Dave/Generated/MOTOR_LIB/motor_lib.h **** void MOTOR_LIB_CordicEnable(void);
 494:../Dave/Generated/MOTOR_LIB/motor_lib.h **** #endif
 495:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 496:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @brief This is the implementation of FeedForward controller.
 497:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param handle_ptr Pointer to @ref MOTOR_LIB_FeedForwardHandleType
 498:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param feedforward_input_val Reference input to feedforward
 499:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @return None
 500:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 501:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * \par<b>Description</b><br>
 502:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * This function is the implementation of FeedForward controller.
 503:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * This can be used along with PI controller for fast and steady response.
 504:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 505:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Example Usage:
 506:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @code
 507:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    #include <DAVE.h>
 508:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    int main (void)
 509:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    {
 510:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      int32_t feedforward_input_val = 400;
 511:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      MOTOR_LIB_FeedForwardHandle_t handle;
 512:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      DAVE_STATUS_t status;
 513:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      status = DAVE_Init();
 514:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      MOTOR_LIB_FeedForwardController(&handle,error_val,feedforward_input_val);
 515:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      while(1);
 516:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      return 0;
 517:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    }
 518:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @endcode
 519:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 520:../Dave/Generated/MOTOR_LIB/motor_lib.h **** void MOTOR_LIB_FeedForwardController(MOTOR_LIB_FeedForwardHandle_t *handle_ptr,int32_t feedforward_
 521:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 522:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 523:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @brief This is the implementation of PI controller.
 524:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param handle_ptr Pointer to MOTOR_LIB_PIHandleType
 525:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param error_val Error value for PI controller
 526:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @return None
 527:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 528:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * \par<b>Description</b><br>
 529:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * This function is the implementation of PI controller.\n
 530:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * PI Output = kp*error + Ki * integral of error
 531:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 532:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Example Usage:
 533:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @code
 534:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    #include <DAVE.h>
 535:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    int main (void)
 536:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    {
 537:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      int32_t error_val = 400;
 538:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      MOTOR_LIB_PIHandle_t handle;
 539:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      DAVE_STATUS_t status;
 540:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      status = DAVE_Init();
 541:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      MOTOR_LIB_PIController(&handle,error_val);
 542:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      while(1);
 543:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      return 0;
 544:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    }
 545:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @endcode
 546:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 547:../Dave/Generated/MOTOR_LIB/motor_lib.h **** void MOTOR_LIB_PIController
 548:../Dave/Generated/MOTOR_LIB/motor_lib.h **** (
 549:../Dave/Generated/MOTOR_LIB/motor_lib.h ****     MOTOR_LIB_PIHandle_t *handle_ptr,
 550:../Dave/Generated/MOTOR_LIB/motor_lib.h ****     int32_t error_val
 551:../Dave/Generated/MOTOR_LIB/motor_lib.h **** );
 552:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 553:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @brief This is the implementation of PT1 filter.
 554:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param handle_ptr PT1 Handle pointer
 555:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param actual_val Input value for PT1 filter
 556:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @return None
 557:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 558:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * \par<b>Description</b><br>
 559:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * This function is the implementation of PT1 filter.\n
 560:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Yn[3,2,1,0]  =Yn-1[3,2,1,0] +Z1*(Xn -Yn-1[3,2]) \n
 561:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Where Z1 is time constant.
 562:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 563:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Example Usage:
 564:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @code
 565:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    #include <DAVE.h>
 566:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    int main (void)
 567:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    {
 568:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      int32_t actual_val = 400;
 569:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      MOTOR_LIB_PT1Handle_t handle;
 570:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      DAVE_STATUS_t status;
 571:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      status = DAVE_Init();
 572:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      MOTOR_LIB_PT1Controller(&handle,actual_val);
 573:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      while(1);
 574:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      return 0;
 575:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    }
 576:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @endcode
 577:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 578:../Dave/Generated/MOTOR_LIB/motor_lib.h **** void MOTOR_LIB_PT1Controller
 579:../Dave/Generated/MOTOR_LIB/motor_lib.h **** (
 580:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    MOTOR_LIB_PT1Handle_t *handle_ptr,
 581:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    int32_t actual_val
 582:../Dave/Generated/MOTOR_LIB/motor_lib.h **** );
 583:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 584:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 585:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @brief This is the implementation of PT12 filter.
 586:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param handle_ptr PT1 Handle pointer
 587:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param actual_val Input value for PT1 filter
 588:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @return None
 589:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 590:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * \par<b>Description</b><br>
 591:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * This function is the implementation of PT12 filter.\n
 592:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Yn[3,2,1,0]  =Yn-1[3,2,1,0] +(Z1*Xn -Z2*Yn-1[3,2]) \n
 593:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Where Z1 and Z2 are time constant.
 594:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 595:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Example Usage:
 596:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @code
 597:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    #include <DAVE.h>
 598:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    int main (void)
 599:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    {
 600:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      int32_t actual_val = 400;
 601:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      MOTOR_LIB_PT1Handle_t handle;
 602:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      DAVE_STATUS_t status;
 603:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      status = DAVE_Init();
 604:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      MOTOR_LIB_PT12Controller(&handle,actual_val);
 605:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      while(1);
 606:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      return 0;
 607:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    }
 608:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @endcode
 609:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 610:../Dave/Generated/MOTOR_LIB/motor_lib.h **** void MOTOR_LIB_PT12Controller
 611:../Dave/Generated/MOTOR_LIB/motor_lib.h **** (
 612:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    MOTOR_LIB_PT1Handle_t *handle_ptr,
 613:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    int32_t actual_val
 614:../Dave/Generated/MOTOR_LIB/motor_lib.h **** );
 615:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 616:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 617:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @brief This is the implementation of clark transform based on two phase current measurement.
 618:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param phase_a  Phase A current value
 619:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param phase_b  Phase B current value
 620:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param i_alpha Pointer to output value Ialpha
 621:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @return i_beta
 622:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 623:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * \par<b>Description</b><br>
 624:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * This function is the implementation of clark transform.\n
 625:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * It will determine the stator current projection in a two co-ordinate non-rotating frame(Ialpha 
 626:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Ialpha = Phase_A/2 \n
 627:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Ibeta  = (Phase_A+2*Phase_B)/(2*Sqrt(3))
 628:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 629:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Example Usage:
 630:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @code
 631:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    #include <DAVE.h>
 632:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    int main (void)
 633:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    {
 634:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      int32_t ialpha,ibeta;
 635:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      DAVE_STATUS_t status;
 636:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      status = DAVE_Init();
 637:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      ibeta = MOTOR_LIB_ClarkTransform(1000,400,&ialpha);
 638:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      while(1);
 639:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      return 0;
 640:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    }
 641:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @endcode
 642:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 643:../Dave/Generated/MOTOR_LIB/motor_lib.h **** int32_t MOTOR_LIB_ClarkTransform(int32_t phase_a, int32_t phase_b, int32_t *i_alpha );
 644:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 645:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 646:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @brief This is the implementation of clark transform based on three phase current measurement.
 647:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param phase_a  Phase A current value
 648:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param phase_b  Phase B current value
 649:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param phase_c  Phase C current value
 650:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param i_alpha Pointer to output value Ialpha
 651:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @return  Ibeta <BR>
 652:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 653:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * \par<b>Description</b><br>
 654:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * This function is the implementation of clark transform. \n
 655:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * It will determine the stator current projection in a two co-ordinate non-rotating frame(Ialpha 
 656:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Ialpha = (2*Phase_A -Phase_B-Phase_C)/2 \n
 657:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Ibeta  = (Phase_B-Phase_C)/(2*Sqrt(3)) \n
 658:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 659:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Example Usage:
 660:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @code
 661:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    #include <DAVE.h>
 662:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    int main (void)
 663:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    {
 664:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      int32_t ialpha,ibeta;
 665:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      DAVE_STATUS_t status;
 666:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      status = DAVE_Init();
 667:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      ibeta = MOTOR_LIB_ClarkTransform2(1000,400,800,&ialpha);
 668:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      while(1);
 669:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      return 0;
 670:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    }
 671:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @endcode
 672:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 673:../Dave/Generated/MOTOR_LIB/motor_lib.h **** int32_t MOTOR_LIB_ClarkTransform2(int32_t phase_a, int32_t phase_b, int32_t phase_c, int32_t *i_alp
 674:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 675:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 676:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @brief This is the implementation of park transform.
 677:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param i_alpha Ialpha(non-rotating frame)
 678:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param i_beta  Ibeta(non-rotating frame)
 679:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param angle  Angle
 680:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param Pointer to output Iq value
 681:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @return  Id
 682:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 683:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * \par<b>Description</b><br>
 684:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * This function is the implementation of park transform. \n
 685:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * It will determine the projection in the (Id,Iq) rotating frame. \n
 686:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Id  =k*(Ialpha*cos(Angle)+Ibeta*sin(Angle))/2  ; where k = 1.64767 \n
 687:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Iq  =k*(-Ialpha*sin(Angle)+Ibeta*cos(Angle))/2 ; where k = 1.64767 \n
 688:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 689:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * \par<b>Note</b><br>
 690:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * On XMC13 device this API will use HW CORDIC module for computation of trigonometric, hyperbolic
 691:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 692:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Example Usage:
 693:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @code
 694:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    #include <DAVE.h>
 695:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    int main (void)
 696:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    {
 697:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      int32_t ialpha,ibeta,iq,id;
 698:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      DAVE_STATUS_t status;
 699:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      status = DAVE_Init();
 700:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      id = MOTOR_LIB_ParkTransform(1000,400,800,&iq);
 701:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      while(1);
 702:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      return 0;
 703:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    }
 704:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @endcode
 705:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 706:../Dave/Generated/MOTOR_LIB/motor_lib.h **** int32_t MOTOR_LIB_ParkTransform(int32_t i_alpha,int32_t i_beta,int16_t angle,int32_t *iq);
 707:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 708:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 709:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @brief This is the implementation of inverse park transform.
 710:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param vd  Vd Voltage component on d-axis
 711:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param vq  Vq Voltage component on q-axis
 712:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param angle Angle
 713:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param vbeta Pointer to output Vbeta value
 714:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @return Valpha <BR>
 715:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 716:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * \par<b>Description</b><br>
 717:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * This function is the implementation of inverse park transform. \n
 718:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Valpha  = k*(Vd*cos(Angle)- Vq*sin(Angle))/4 ; where k = 1.64767 \n
 719:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Vbeta   = k*(Vd*sin(Angle)+Vq*cos(Angle))/4 ; where k = 1.64767 \n
 720:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 721:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * \par<b>Note</b><br>
 722:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * On XMC13 device this API will use HW CORDIC module for computation of trigonometric, hyperbolic
 723:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 724:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Example Usage:
 725:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @code
 726:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    #include <DAVE.h>
 727:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    int main (void)
 728:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    {
 729:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      int32_t valpha,vbeta;
 730:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      int16_t angle;
 731:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      DAVE_STATUS_t status;
 732:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      status = DAVE_Init();
 733:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      valpha = MOTOR_LIB_IParkTransform(1000,400,&vbeta);
 734:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      while(1);
 735:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      return 0;
 736:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    }
 737:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @endcode
 738:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 739:../Dave/Generated/MOTOR_LIB/motor_lib.h **** int32_t MOTOR_LIB_IParkTransform(int32_t vd,int32_t vq,int16_t angle,int32_t *vbeta);
 740:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 741:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 742:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @brief This is the implementation cartesian to polar transform.
 743:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param x  Input X co-ordinate value
 744:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param y  Input Y co-ordinate value
 745:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param angle Pointer to output angle value
 746:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @return  Amplitude <BR>
 747:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 748:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * \par<b>Description</b><br>
 749:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * This function is the implementation cartesian to polar transform.\n
 750:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Amplitude  = K * SQRT(x*x+y*y); where k = 1.64767 \n
 751:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Angle      = ATAN(y/x); \n
 752:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 753:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * \par<b>Note</b><br>
 754:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * On XMC13 device this API will use HW CORDIC module for computation of trigonometric, hyperbolic
 755:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 756:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Example Usage:
 757:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @code
 758:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    #include <DAVE.h>
 759:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    int main (void)
 760:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    {
 761:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      uint32_t amplitude;
 762:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      int16_t angle;
 763:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      DAVE_STATUS_t status;
 764:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      status = DAVE_Init();
 765:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      amplitude = MOTOR_LIB_Car2Pol(1000,400,&angle);
 766:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      while(1);
 767:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      return 0;
 768:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    }
 769:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @endcode
 770:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 771:../Dave/Generated/MOTOR_LIB/motor_lib.h **** uint32_t MOTOR_LIB_Car2Pol(int32_t x,int32_t y, int16_t *angle);
 772:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 773:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 774:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @brief This is the implementation polar to cartesian transform.
 775:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param angle  Polar angle
 776:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param amplitude Amplitude
 777:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param x Pointer to output X co-ordinate value
 778:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @return  Y co-ordinate value <BR>
 779:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 780:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * \par<b>Description</b><br>
 781:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * This function is the implementation polar to cartesian transform.\n
 782:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * X = K * Amplitude* cos(Angle); where k = 1.64767  \n
 783:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Y = K * Amplitude* sin(Angle); where k = 1.64767  \n
 784:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 785:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * \par<b>Note</b><br>
 786:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * On XMC13 device this API will use HW CORDIC module for computation of trigonometric, hyperbolic
 787:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 788:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Example Usage:
 789:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @code
 790:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    #include <DAVE.h>
 791:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    int main (void)
 792:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    {
 793:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      int32_t x,y;
 794:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      DAVE_STATUS_t status;
 795:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      status = DAVE_Init();
 796:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      y = MOTOR_LIB_Pol2Car(1000,400,&x);
 797:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      while(1);
 798:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      return 0;
 799:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    }
 800:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @endcode
 801:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 802:../Dave/Generated/MOTOR_LIB/motor_lib.h **** int32_t MOTOR_LIB_Pol2Car(int16_t angle,uint32_t amplitude, int32_t *x);
 803:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 804:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 805:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * @brief Returns APP version information
 806:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * @param None
 807:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * @return DAVE_APP_VERSION_t Returns APP version number(major, minor and patch number).
 808:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * <BR>
 809:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *
 810:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * \par<b>Description</b><br>
 811:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * Each of the DAVE APP exports a version number(major, minor and patch number).
 812:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * Applications may then audit such a version number to determine compatibility.
 813:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  *
 814:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * Example Usage:
 815:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * @code
 816:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  #include <DAVE.h>
 817:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  int main (void)
 818:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  {
 819:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   DAVE_STATUS_t status;
 820:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   DAVE_APP_VERSION_t version;
 821:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   status = DAVE_Init();
 822:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   version = MOTOR_LIB_GetAppVersion();
 823:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   if (version.major != 1U)
 824:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   {
 825:../Dave/Generated/MOTOR_LIB/motor_lib.h ****     // Probably, not the right version.
 826:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   }
 827:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   while(1);
 828:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   return 0;
 829:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  }
 830:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * @endcode
 831:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  */
 832:../Dave/Generated/MOTOR_LIB/motor_lib.h **** DAVE_APP_VERSION_t MOTOR_LIB_GetAppVersion(void);
 833:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 834:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 835:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @brief Returns the magnitude of resultant vector in circular mode.
 836:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param x  Input X/k co-ordinate value
 837:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param y  Input Y/k co-ordinate value
 838:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @return  Magnitude of resultant vector in circular mode <BR>
 839:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 840:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * \par<b>Description</b><br>
 841:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * This function returns the magnitude of resultant vector in circular mode.\n
 842:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Magnitude  = SQRT(x*x+y*y); where k = 1.64767 \n
 843:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 844:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * \par<b>Note</b><br>
 845:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * On XMC13 device this API will use HW CORDIC module for computation of trigonometric, hyperbolic
 846:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 847:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Example Usage:
 848:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @code
 849:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    #include <DAVE.h>
 850:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    int main (void)
 851:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    {
 852:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      uint32_t magnitude;
 853:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      int16_t angle;
 854:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      DAVE_STATUS_t status;
 855:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      status = DAVE_Init();
 856:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      magnitude = MOTOR_LIB_ResultantMagnitudeCircular(1000,400);
 857:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      while(1);
 858:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      return 0;
 859:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    }
 860:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @endcode
 861:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 862:../Dave/Generated/MOTOR_LIB/motor_lib.h **** uint32_t MOTOR_LIB_ResultantMagnitudeCircular(int32_t x,int32_t y);
 863:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 864:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 865:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @brief Returns the magnitude of resultant vector in hyperbolic mode.
 866:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param x  Input X/k co-ordinate value
 867:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @param y  Input Y/k co-ordinate value
 868:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @return  Magnitude of resultant vector in hyperbolic mode <BR>
 869:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 870:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * \par<b>Description</b><br>
 871:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * This function returns the magnitude of resultant vector in hyperbolic mode.\n
 872:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Magnitude  = SQRT(x*x-y*y); where k = 0.828159360960 \n
 873:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 874:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * \par<b>Note</b><br>
 875:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * On XMC13 device this API will use HW CORDIC module for computation of trigonometric, hyperbolic
 876:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * x should be greater than y.
 877:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   *
 878:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * Example Usage:
 879:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @code
 880:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    #include <DAVE.h>
 881:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    int main (void)
 882:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    {
 883:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      uint32_t magnitude;
 884:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      int16_t angle;
 885:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      DAVE_STATUS_t status;
 886:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      status = DAVE_Init();
 887:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      magnitude = MOTOR_LIB_ResultantMagnitudeHyperbolic(1000,400);
 888:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      while(1);
 889:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      return 0;
 890:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    }
 891:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   * @endcode
 892:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   */
 893:../Dave/Generated/MOTOR_LIB/motor_lib.h **** uint32_t MOTOR_LIB_ResultantMagnitudeHyperbolic(int32_t x,int32_t y);
 894:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 895:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /**
 896:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  * @}
 897:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  */
 898:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 899:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /*Limits the input value based on higher_limit and lower_limit*/
 900:../Dave/Generated/MOTOR_LIB/motor_lib.h **** static inline int32_t MOTOR_LIB_MinMaxLimiter(int32_t input_val,int32_t higher_limit,int32_t lower_
 901:../Dave/Generated/MOTOR_LIB/motor_lib.h **** {
  27              	 .loc 1 901 0
  28              	 .cfi_startproc
  29              	 
  30              	 
  31              	 
  32 0000 80B4     	 push {r7}
  33              	.LCFI0:
  34              	 .cfi_def_cfa_offset 4
  35              	 .cfi_offset 7,-4
  36 0002 87B0     	 sub sp,sp,#28
  37              	.LCFI1:
  38              	 .cfi_def_cfa_offset 32
  39 0004 00AF     	 add r7,sp,#0
  40              	.LCFI2:
  41              	 .cfi_def_cfa_register 7
  42 0006 F860     	 str r0,[r7,#12]
  43 0008 B960     	 str r1,[r7,#8]
  44 000a 7A60     	 str r2,[r7,#4]
 902:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   int32_t return_val;
 903:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   if ( input_val > higher_limit )
  45              	 .loc 1 903 0
  46 000c FA68     	 ldr r2,[r7,#12]
  47 000e BB68     	 ldr r3,[r7,#8]
  48 0010 9A42     	 cmp r2,r3
  49 0012 02DD     	 ble .L2
 904:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   {
 905:../Dave/Generated/MOTOR_LIB/motor_lib.h ****     return_val = higher_limit;
  50              	 .loc 1 905 0
  51 0014 BB68     	 ldr r3,[r7,#8]
  52 0016 7B61     	 str r3,[r7,#20]
  53 0018 08E0     	 b .L3
  54              	.L2:
 906:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   }
 907:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   else if ( input_val < lower_limit )
  55              	 .loc 1 907 0
  56 001a FA68     	 ldr r2,[r7,#12]
  57 001c 7B68     	 ldr r3,[r7,#4]
  58 001e 9A42     	 cmp r2,r3
  59 0020 02DA     	 bge .L4
 908:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   {
 909:../Dave/Generated/MOTOR_LIB/motor_lib.h ****     return_val = lower_limit;
  60              	 .loc 1 909 0
  61 0022 7B68     	 ldr r3,[r7,#4]
  62 0024 7B61     	 str r3,[r7,#20]
  63 0026 01E0     	 b .L3
  64              	.L4:
 910:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   }
 911:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   else
 912:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   {
 913:../Dave/Generated/MOTOR_LIB/motor_lib.h ****     return_val = input_val;
  65              	 .loc 1 913 0
  66 0028 FB68     	 ldr r3,[r7,#12]
  67 002a 7B61     	 str r3,[r7,#20]
  68              	.L3:
 914:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   }
 915:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   return return_val;
  69              	 .loc 1 915 0
  70 002c 7B69     	 ldr r3,[r7,#20]
 916:../Dave/Generated/MOTOR_LIB/motor_lib.h **** }
  71              	 .loc 1 916 0
  72 002e 1846     	 mov r0,r3
  73 0030 1C37     	 adds r7,r7,#28
  74              	.LCFI3:
  75              	 .cfi_def_cfa_offset 4
  76 0032 BD46     	 mov sp,r7
  77              	.LCFI4:
  78              	 .cfi_def_cfa_register 13
  79              	 
  80 0034 5DF8047B 	 ldr r7,[sp],#4
  81              	.LCFI5:
  82              	 .cfi_restore 7
  83              	 .cfi_def_cfa_offset 0
  84 0038 7047     	 bx lr
  85              	 .cfi_endproc
  86              	.LFE128:
  88 003a 00BF     	 .section .text.MOTOR_LIB_abs,"ax",%progbits
  89              	 .align 2
  90              	 .thumb
  91              	 .thumb_func
  93              	MOTOR_LIB_abs:
  94              	.LFB130:
 917:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 918:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  /*Limits the 64 bit input value based on higher_limit and lower_limit*/
 919:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  static inline int64_t MOTOR_LIB_MinMaxLimiter64(int64_t input_val,int64_t higher_limit,int64_t low
 920:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  {
 921:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    int64_t return_val;
 922:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    if ( input_val > higher_limit )
 923:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    {
 924:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      return_val = higher_limit;
 925:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    }
 926:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    else if ( input_val < lower_limit )
 927:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    {
 928:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      return_val = lower_limit;
 929:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    }
 930:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    else
 931:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    {
 932:../Dave/Generated/MOTOR_LIB/motor_lib.h ****      return_val = input_val;
 933:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    }
 934:../Dave/Generated/MOTOR_LIB/motor_lib.h ****    return return_val;
 935:../Dave/Generated/MOTOR_LIB/motor_lib.h ****  }
 936:../Dave/Generated/MOTOR_LIB/motor_lib.h **** 
 937:../Dave/Generated/MOTOR_LIB/motor_lib.h **** /*This is used to find out the absolute value*/
 938:../Dave/Generated/MOTOR_LIB/motor_lib.h **** static inline uint32_t MOTOR_LIB_abs(int32_t x)
 939:../Dave/Generated/MOTOR_LIB/motor_lib.h **** {
  95              	 .loc 1 939 0
  96              	 .cfi_startproc
  97              	 
  98              	 
  99              	 
 100 0000 80B4     	 push {r7}
 101              	.LCFI6:
 102              	 .cfi_def_cfa_offset 4
 103              	 .cfi_offset 7,-4
 104 0002 85B0     	 sub sp,sp,#20
 105              	.LCFI7:
 106              	 .cfi_def_cfa_offset 24
 107 0004 00AF     	 add r7,sp,#0
 108              	.LCFI8:
 109              	 .cfi_def_cfa_register 7
 110 0006 7860     	 str r0,[r7,#4]
 940:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   int32_t return_val;
 941:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   if(x > 0)
 111              	 .loc 1 941 0
 112 0008 7B68     	 ldr r3,[r7,#4]
 113 000a 002B     	 cmp r3,#0
 114 000c 02DD     	 ble .L7
 942:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   {
 943:../Dave/Generated/MOTOR_LIB/motor_lib.h ****     return_val = x;
 115              	 .loc 1 943 0
 116 000e 7B68     	 ldr r3,[r7,#4]
 117 0010 FB60     	 str r3,[r7,#12]
 118 0012 02E0     	 b .L8
 119              	.L7:
 944:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   }
 945:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   else
 946:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   {
 947:../Dave/Generated/MOTOR_LIB/motor_lib.h ****     return_val = (-x);
 120              	 .loc 1 947 0
 121 0014 7B68     	 ldr r3,[r7,#4]
 122 0016 5B42     	 negs r3,r3
 123 0018 FB60     	 str r3,[r7,#12]
 124              	.L8:
 948:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   }
 949:../Dave/Generated/MOTOR_LIB/motor_lib.h ****   return ((uint32_t)return_val);
 125              	 .loc 1 949 0
 126 001a FB68     	 ldr r3,[r7,#12]
 950:../Dave/Generated/MOTOR_LIB/motor_lib.h **** }
 127              	 .loc 1 950 0
 128 001c 1846     	 mov r0,r3
 129 001e 1437     	 adds r7,r7,#20
 130              	.LCFI9:
 131              	 .cfi_def_cfa_offset 4
 132 0020 BD46     	 mov sp,r7
 133              	.LCFI10:
 134              	 .cfi_def_cfa_register 13
 135              	 
 136 0022 5DF8047B 	 ldr r7,[sp],#4
 137              	.LCFI11:
 138              	 .cfi_restore 7
 139              	 .cfi_def_cfa_offset 0
 140 0026 7047     	 bx lr
 141              	 .cfi_endproc
 142              	.LFE130:
 144              	 .global MOTOR_LIB_E
 145              	 .section .rodata.MOTOR_LIB_E,"a",%progbits
 146              	 .align 2
 149              	MOTOR_LIB_E:
 150 0000 00000020 	 .word 536870912
 151 0004 1D05E412 	 .word 316933405
 152 0008 5B38FB09 	 .word 167458907
 153 000c D4111105 	 .word 85004756
 154 0010 430D8B02 	 .word 42667331
 155 0014 E1D74501 	 .word 21354465
 156 0018 1EF6A200 	 .word 10679838
 157 001c 557C5100 	 .word 5340245
 158 0020 53BE2800 	 .word 2670163
 159 0024 2E5F1400 	 .word 1335086
 160 0028 982F0A00 	 .word 667544
 161 002c CC170500 	 .word 333772
 162 0030 E68B0200 	 .word 166886
 163 0034 F3450100 	 .word 83443
 164 0038 F9A20000 	 .word 41721
 165 003c 7C510000 	 .word 20860
 166 0040 BE280000 	 .word 10430
 167 0044 5F140000 	 .word 5215
 168 0048 2F0A0000 	 .word 2607
 169 004c 17050000 	 .word 1303
 170 0050 8B020000 	 .word 651
 171 0054 45010000 	 .word 325
 172 0058 A2000000 	 .word 162
 173              	 .section .text.MOTOR_LIB_GetAppVersion,"ax",%progbits
 174              	 .align 2
 175              	 .global MOTOR_LIB_GetAppVersion
 176              	 .thumb
 177              	 .thumb_func
 179              	MOTOR_LIB_GetAppVersion:
 180              	.LFB131:
 181              	 .file 2 "../Dave/Generated/MOTOR_LIB/motor_lib.c"
   1:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**
   2:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * @file motor_lib.c
   3:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * @date 2015-10-08
   4:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *
   5:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * NOTE:
   6:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * This file is generated by DAVE. Any manual modification done to this file will be lost when the 
   7:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *
   8:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * @cond
   9:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  **************************************************************************************************
  10:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * MOTOR_LIB v4.0.8 - Provides common motor control library API's.
  11:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *
  12:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * Copyright (c) 2015-2017, Infineon Technologies AG
  13:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * All rights reserved.
  14:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *
  15:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  16:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * following conditions are met:
  17:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *
  18:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *   Redistributions of source code must retain the above copyright notice, this list of conditions
  19:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *   disclaimer.
  20:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *
  21:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *   Redistributions in binary form must reproduce the above copyright notice, this list of conditi
  22:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *   following disclaimer in the documentation and/or other materials provided with the distributio
  23:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *
  24:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *   Neither the name of the copyright holders nor the names of its contributors may be used to end
  25:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *   products derived from this software without specific prior written permission.
  26:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *
  27:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  28:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  29:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  30:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  31:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  32:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  33:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *
  35:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  36:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * with Infineon Technologies AG (dave@infineon.com).
  37:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  **************************************************************************************************
  38:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *
  39:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * Change History
  40:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * --------------
  41:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *
  42:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * 2015-02-20:
  43:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *     - Initial version
  44:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *
  45:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * 2015-06-20:
  46:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *     - Vector magnitude calculation API's are added
  47:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *
  48:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * @endcond
  49:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  *
  50:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  */
  51:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
  52:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**************************************************************************************************
  53:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * HEADER FILES
  54:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  **************************************************************************************************
  55:../Dave/Generated/MOTOR_LIB/motor_lib.c **** #include "motor_lib.h"
  56:../Dave/Generated/MOTOR_LIB/motor_lib.c **** #if defined (MATH)
  57:../Dave/Generated/MOTOR_LIB/motor_lib.c **** #include <xmc_scu.h>
  58:../Dave/Generated/MOTOR_LIB/motor_lib.c **** #endif
  59:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
  60:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**************************************************************************************************
  61:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * MACROS
  62:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  **************************************************************************************************
  63:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
  64:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**************************************************************************************************
  65:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * LOCAL DATA
  66:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  **************************************************************************************************
  67:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
  68:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**************************************************************************************************
  69:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * LOCAL ROUTINES
  70:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  **************************************************************************************************
  71:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
  72:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**
  73:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * @ingroup MOTOTLIBS_constants
  74:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * @{
  75:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  */
  76:../Dave/Generated/MOTOR_LIB/motor_lib.c **** #if !defined (MATH)
  77:../Dave/Generated/MOTOR_LIB/motor_lib.c **** const int32_t MOTOR_LIB_E[23] =
  78:../Dave/Generated/MOTOR_LIB/motor_lib.c **** {0x20000000, 0x12E4051D, 0x9FB385B, 0x51111D4, 0x28B0D43, 0x145D7E1, 0xA2F61E,
  79:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  0x517C55, 0x28BE53, 0x145F2E, 0xA2F98, 0x517CC, 0x28BE6, 0x145F3, 0xA2F9, 0x517C,
  80:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  0x28BE, 0x145F, 0xA2F, 0x517, 0x28B, 0x145, 0xA2};
  81:../Dave/Generated/MOTOR_LIB/motor_lib.c **** #endif
  82:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
  83:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**************************************************************************************************
  84:../Dave/Generated/MOTOR_LIB/motor_lib.c **** * API IMPLEMENTATION
  85:../Dave/Generated/MOTOR_LIB/motor_lib.c **** ***************************************************************************************************
  86:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /* App API to retrieve the App version info */
  87:../Dave/Generated/MOTOR_LIB/motor_lib.c **** DAVE_APP_VERSION_t MOTOR_LIB_GetAppVersion(void)
  88:../Dave/Generated/MOTOR_LIB/motor_lib.c **** {
 182              	 .loc 2 88 0
 183              	 .cfi_startproc
 184              	 
 185              	 
 186              	 
 187 0000 80B4     	 push {r7}
 188              	.LCFI12:
 189              	 .cfi_def_cfa_offset 4
 190              	 .cfi_offset 7,-4
 191 0002 83B0     	 sub sp,sp,#12
 192              	.LCFI13:
 193              	 .cfi_def_cfa_offset 16
 194 0004 00AF     	 add r7,sp,#0
 195              	.LCFI14:
 196              	 .cfi_def_cfa_register 7
  89:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   DAVE_APP_VERSION_t version;
  90:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
  91:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   version.major = MOTOR_LIB_MAJOR_VERSION;
 197              	 .loc 2 91 0
 198 0006 0423     	 movs r3,#4
 199 0008 3B70     	 strb r3,[r7]
  92:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   version.minor = MOTOR_LIB_MINOR_VERSION;
 200              	 .loc 2 92 0
 201 000a 0023     	 movs r3,#0
 202 000c 7B70     	 strb r3,[r7,#1]
  93:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   version.patch = MOTOR_LIB_PATCH_VERSION;
 203              	 .loc 2 93 0
 204 000e 0823     	 movs r3,#8
 205 0010 BB70     	 strb r3,[r7,#2]
  94:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
  95:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   return version;
 206              	 .loc 2 95 0
 207 0012 3B1D     	 adds r3,r7,#4
 208 0014 3A46     	 mov r2,r7
 209 0016 1268     	 ldr r2,[r2]
 210 0018 1146     	 mov r1,r2
 211 001a 1980     	 strh r1,[r3]
 212 001c 0233     	 adds r3,r3,#2
 213 001e 120C     	 lsrs r2,r2,#16
 214 0020 1A70     	 strb r2,[r3]
 215 0022 0023     	 movs r3,#0
 216 0024 3A79     	 ldrb r2,[r7,#4]
 217 0026 62F30703 	 bfi r3,r2,#0,#8
 218 002a 7A79     	 ldrb r2,[r7,#5]
 219 002c 62F30F23 	 bfi r3,r2,#8,#8
 220 0030 BA79     	 ldrb r2,[r7,#6]
 221 0032 62F31743 	 bfi r3,r2,#16,#8
  96:../Dave/Generated/MOTOR_LIB/motor_lib.c **** }
 222              	 .loc 2 96 0
 223 0036 1846     	 mov r0,r3
 224 0038 0C37     	 adds r7,r7,#12
 225              	.LCFI15:
 226              	 .cfi_def_cfa_offset 4
 227 003a BD46     	 mov sp,r7
 228              	.LCFI16:
 229              	 .cfi_def_cfa_register 13
 230              	 
 231 003c 5DF8047B 	 ldr r7,[sp],#4
 232              	.LCFI17:
 233              	 .cfi_restore 7
 234              	 .cfi_def_cfa_offset 0
 235 0040 7047     	 bx lr
 236              	 .cfi_endproc
 237              	.LFE131:
 239 0042 00BF     	 .section .text.MOTOR_LIB_Car2Pol,"ax",%progbits
 240              	 .align 2
 241              	 .global MOTOR_LIB_Car2Pol
 242              	 .thumb
 243              	 .thumb_func
 245              	MOTOR_LIB_Car2Pol:
 246              	.LFB132:
  97:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
  98:../Dave/Generated/MOTOR_LIB/motor_lib.c **** #if defined (MATH)
  99:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**
 100:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * This function will enable HW Cordic for XMC13 device.
 101:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  */
 102:../Dave/Generated/MOTOR_LIB/motor_lib.c **** void MOTOR_LIB_CordicEnable(void)
 103:../Dave/Generated/MOTOR_LIB/motor_lib.c **** {
 104:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /*Ungate Math coprocessor*/
 105:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_MATH);
 106:../Dave/Generated/MOTOR_LIB/motor_lib.c **** }
 107:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 108:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**
 109:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * This function is the implementation of cartesian to Polar Transformation.
 110:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  */
 111:../Dave/Generated/MOTOR_LIB/motor_lib.c **** uint32_t MOTOR_LIB_Car2Pol(int32_t x,int32_t y, int16_t *angle)
 112:../Dave/Generated/MOTOR_LIB/motor_lib.c **** {
 113:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   int32_t temp_angle;
 114:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 115:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /*Clearing previous values of CORDX,CORDY and CORDZ Registers*/
 116:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->STATC = (uint32_t) MOTOR_LIB_CLEAR_KEEPX +
 117:../Dave/Generated/MOTOR_LIB/motor_lib.c ****                 (uint32_t) MOTOR_LIB_CLEAR_KEEPY +
 118:../Dave/Generated/MOTOR_LIB/motor_lib.c ****                 (uint32_t) MOTOR_LIB_CLEAR_KEEPZ;
 119:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 120:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CON = (uint32_t) MOTOR_LIB_CIRCULAR_MODE +
 121:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_VECTORING_MODE +
 122:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_CORDIC_AUTO_START +
 123:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_UNSIGNED_X_RESULT +
 124:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_MPS_DIVBY2;
 125:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 126:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /*Loading CORDX,CORDY and CORDZ Registers*/
 127:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CORDZ = (((uint32_t)0 << MATH_CORDZ_DATA_Pos) & ((uint32_t)MATH_CORDZ_DATA_Msk)) |
 128:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (MATH->CORDZ & ((uint32_t)~((uint32_t)MATH_CORDZ_DATA_Msk)));
 129:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 130:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CORDY = (((uint32_t)y << MATH_CORDY_DATA_Pos) & ((uint32_t)MATH_CORDY_DATA_Msk)) |
 131:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (MATH->CORDY & ((uint32_t)~((uint32_t)MATH_CORDY_DATA_Msk)));
 132:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 133:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CORDX = (((uint32_t)x << MATH_CORDX_DATA_Pos) & ((uint32_t)MATH_CORDX_DATA_Msk)) |
 134:../Dave/Generated/MOTOR_LIB/motor_lib.c ****              (MATH->CORDX & ((uint32_t)~((uint32_t)MATH_CORDX_DATA_Msk)));
 135:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 136:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   while(( MATH->STATC & 0x1U )== 1U)
 137:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 138:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /*Checking for CORIDC Busy Bit*/
 139:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 140:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /* Update the Amplitude and Angle Values*/
 141:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   temp_angle = (int32_t)MATH->CORRZ;
 142:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   *angle  = (int16_t)(temp_angle /((int32_t)((uint32_t)1U<<(MOTOR_LIB_ANGLESCALE_SHIFT +
 143:../Dave/Generated/MOTOR_LIB/motor_lib.c ****                   MOTOR_LIB_CORDZ_DATA_POSSCALE_SHIFT))));
 144:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 145:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   return (((MATH->CORRX*(uint32_t)MOTOR_LIB_INV_KCORDIC)/ ((uint32_t)MOTOR_LIB_KCORDIC_SCALE*(uint3
 146:../Dave/Generated/MOTOR_LIB/motor_lib.c **** }
 147:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 148:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**
 149:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * This function is the implementation of Polar to cartesian Transformation.
 150:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  */
 151:../Dave/Generated/MOTOR_LIB/motor_lib.c **** int32_t MOTOR_LIB_Pol2Car(int16_t angle,uint32_t amplitude, int32_t *x)
 152:../Dave/Generated/MOTOR_LIB/motor_lib.c **** {
 153:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   uint32_t temp_angle;
 154:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   int32_t temp_x, temp_y;
 155:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   temp_angle =(uint16_t)angle;
 156:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /*Clearing previous values of CORDX,CORDY and CORDZ Registers*/
 157:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->STATC = (uint32_t) MOTOR_LIB_CLEAR_KEEPX +
 158:../Dave/Generated/MOTOR_LIB/motor_lib.c ****                 (uint32_t) MOTOR_LIB_CLEAR_KEEPY +
 159:../Dave/Generated/MOTOR_LIB/motor_lib.c ****                 (uint32_t) MOTOR_LIB_CLEAR_KEEPZ;
 160:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 161:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CON = (uint32_t) MOTOR_LIB_CIRCULAR_MODE +
 162:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_ROTATION_MODE +
 163:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_CORDIC_AUTO_START +
 164:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_UNSIGNED_X_RESULT +
 165:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_MPS_DIVBY2;
 166:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 167:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /*Loading CORDX,CORDY and CORDZ Registers*/
 168:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CORDZ= (uint32_t)(temp_angle <<(MOTOR_LIB_ANGLESCALE_SHIFT + MOTOR_LIB_CORDZ_DATA_POSSCALE_
 169:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 170:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CORDY = (((uint32_t)0 << MATH_CORDY_DATA_Pos) & ((uint32_t)MATH_CORDY_DATA_Msk)) |
 171:../Dave/Generated/MOTOR_LIB/motor_lib.c ****              (MATH->CORDY & ((uint32_t)~((uint32_t)MATH_CORDY_DATA_Msk)));
 172:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 173:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CORDX = (((uint32_t)amplitude<< MATH_CORDX_DATA_Pos) & ((uint32_t)MATH_CORDX_DATA_Msk)) |
 174:../Dave/Generated/MOTOR_LIB/motor_lib.c ****              (MATH->CORDX & ((uint32_t)~((uint32_t)MATH_CORDX_DATA_Msk)));
 175:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 176:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   while((MATH->STATC & 0x1U) == 1U)
 177:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 178:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /*Checking for CORIDC Busy Bit*/
 179:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 180:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /* Update the x and y Values*/
 181:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   temp_x = (int32_t)MATH->CORRX;
 182:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   temp_y = (int32_t)MATH->CORRY;
 183:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 184:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   *x = (((temp_x*MOTOR_LIB_INV_KCORDIC)/ (MOTOR_LIB_KCORDIC_SCALE*MOTOR_LIB_AMPSCALE)));
 185:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   return (((temp_y*MOTOR_LIB_INV_KCORDIC)/ (MOTOR_LIB_KCORDIC_SCALE*MOTOR_LIB_AMPSCALE)));
 186:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 187:../Dave/Generated/MOTOR_LIB/motor_lib.c **** }
 188:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 189:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**
 190:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * This function is the implementation of park transform.
 191:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  */
 192:../Dave/Generated/MOTOR_LIB/motor_lib.c **** int32_t MOTOR_LIB_ParkTransform(int32_t i_alpha,int32_t i_beta,int16_t angle,int32_t *iq)
 193:../Dave/Generated/MOTOR_LIB/motor_lib.c **** {
 194:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   uint32_t temp_angle;
 195:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   int32_t temp_d, temp_q;
 196:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   temp_angle =(uint16_t)angle;
 197:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /*Clearing previous values of CORDX,CORDY and CORDZ Registers*/
 198:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->STATC = (uint32_t) MOTOR_LIB_CLEAR_KEEPX +
 199:../Dave/Generated/MOTOR_LIB/motor_lib.c ****                 (uint32_t) MOTOR_LIB_CLEAR_KEEPY +
 200:../Dave/Generated/MOTOR_LIB/motor_lib.c ****                 (uint32_t) MOTOR_LIB_CLEAR_KEEPZ;
 201:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 202:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CON = (uint32_t) MOTOR_LIB_CIRCULAR_MODE +
 203:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_ROTATION_MODE +
 204:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_CORDIC_AUTO_START +
 205:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_UNSIGNED_X_RESULT +
 206:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_MPS_DIVBY2;
 207:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 208:../Dave/Generated/MOTOR_LIB/motor_lib.c ****    /*Loading CORDX,CORDY and CORDZ Registers*/
 209:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CORDZ = (uint32_t)(temp_angle <<(MOTOR_LIB_ANGLESCALE_SHIFT + MOTOR_LIB_CORDZ_DATA_POSSCALE
 210:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 211:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CORDY = (((uint32_t)i_alpha<< MATH_CORDY_DATA_Pos) & ((uint32_t)MATH_CORDY_DATA_Msk)) |
 212:../Dave/Generated/MOTOR_LIB/motor_lib.c ****              (MATH->CORDY & ((uint32_t)~((uint32_t)MATH_CORDY_DATA_Msk)));
 213:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 214:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CORDX = (((uint32_t)i_beta<< MATH_CORDX_DATA_Pos) & ((uint32_t)MATH_CORDX_DATA_Msk)) |
 215:../Dave/Generated/MOTOR_LIB/motor_lib.c ****              (MATH->CORDX & ((uint32_t)~((uint32_t)MATH_CORDX_DATA_Msk)));
 216:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 217:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   while(( MATH->STATC & 0x1U ) == 1U)
 218:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 219:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /*Checking for CORIDC Busy Bit*/
 220:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 221:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /* Update the Amplitude and Angle Values*/
 222:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   temp_q = (int32_t)MATH->CORRX;
 223:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   temp_d = (int32_t)MATH->CORRY;
 224:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 225:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   *iq = (((temp_q*MOTOR_LIB_INV_KCORDIC)/ (MOTOR_LIB_KCORDIC_SCALE*MOTOR_LIB_AMPSCALE)));
 226:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   return (((temp_d*MOTOR_LIB_INV_KCORDIC)/ (MOTOR_LIB_KCORDIC_SCALE*MOTOR_LIB_AMPSCALE)));
 227:../Dave/Generated/MOTOR_LIB/motor_lib.c **** }
 228:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 229:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**
 230:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * This function is the implementation of Inverse park transform.
 231:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  */
 232:../Dave/Generated/MOTOR_LIB/motor_lib.c **** int32_t MOTOR_LIB_IParkTransform(int32_t vd,int32_t vq,int16_t angle,int32_t *vbeta)
 233:../Dave/Generated/MOTOR_LIB/motor_lib.c **** {
 234:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   uint32_t temp_angle;
 235:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   int32_t temp_beta, temp_alpha;
 236:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   temp_angle =(uint16_t)angle;
 237:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     /*Clearing previous values of CORDX,CORDY and CORDZ Registers*/
 238:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->STATC = (uint32_t) MOTOR_LIB_CLEAR_KEEPX +
 239:../Dave/Generated/MOTOR_LIB/motor_lib.c ****                 (uint32_t) MOTOR_LIB_CLEAR_KEEPY +
 240:../Dave/Generated/MOTOR_LIB/motor_lib.c ****                 (uint32_t) MOTOR_LIB_CLEAR_KEEPZ;
 241:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 242:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CON = (uint32_t) MOTOR_LIB_CIRCULAR_MODE +
 243:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_ROTATION_MODE +
 244:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_CORDIC_AUTO_START +
 245:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_UNSIGNED_X_RESULT +
 246:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_MPS_DIVBY2;
 247:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 248:../Dave/Generated/MOTOR_LIB/motor_lib.c ****    /*Loading CORDX,CORDY and CORDZ Registers*/
 249:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CORDZ= (uint32_t)(temp_angle <<(MOTOR_LIB_ANGLESCALE_SHIFT + MOTOR_LIB_CORDZ_DATA_POSSCALE_
 250:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 251:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CORDY = (((uint32_t)vq<< MATH_CORDY_DATA_Pos) & ((uint32_t)MATH_CORDY_DATA_Msk)) |
 252:../Dave/Generated/MOTOR_LIB/motor_lib.c ****              (MATH->CORDY & ((uint32_t)~((uint32_t)MATH_CORDY_DATA_Msk)));
 253:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 254:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CORDX = (((uint32_t)vd<< MATH_CORDX_DATA_Pos) & ((uint32_t)MATH_CORDX_DATA_Msk)) |
 255:../Dave/Generated/MOTOR_LIB/motor_lib.c ****              (MATH->CORDX & ((uint32_t)~((uint32_t)MATH_CORDX_DATA_Msk)));
 256:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 257:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   while((MATH->STATC & 0x1U)== 1U)
 258:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 259:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /*Checking for CORIDC Busy Bit*/
 260:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 261:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 262:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /* Update the Amplitude and Angle Values*/
 263:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   temp_alpha  =(int32_t)MATH->CORRX;
 264:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   temp_beta = (int32_t)MATH->CORRY;
 265:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   *vbeta = (temp_beta / MOTOR_LIB_AMPSCALE);
 266:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   
 267:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   *vbeta = (((temp_beta*MOTOR_LIB_INV_KCORDIC)/ (MOTOR_LIB_KCORDIC_SCALE*MOTOR_LIB_AMPSCALE)));
 268:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   return (((temp_alpha*MOTOR_LIB_INV_KCORDIC)/ (MOTOR_LIB_KCORDIC_SCALE*MOTOR_LIB_AMPSCALE)));
 269:../Dave/Generated/MOTOR_LIB/motor_lib.c **** }
 270:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 271:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**
 272:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * This function returns the magnitude of resultant vector in circular mode.(sqrt(x^2+y^2))
 273:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  */
 274:../Dave/Generated/MOTOR_LIB/motor_lib.c **** uint32_t MOTOR_LIB_ResultantMagnitudeCircular(int32_t x,int32_t y)
 275:../Dave/Generated/MOTOR_LIB/motor_lib.c **** {
 276:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   uint32_t resultant_magnitude;
 277:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /*Clearing previous values of CORDX,CORDY and CORDZ Registers*/
 278:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->STATC = (uint32_t) MOTOR_LIB_CLEAR_KEEPX +
 279:../Dave/Generated/MOTOR_LIB/motor_lib.c ****                 (uint32_t) MOTOR_LIB_CLEAR_KEEPY +
 280:../Dave/Generated/MOTOR_LIB/motor_lib.c ****                 (uint32_t) MOTOR_LIB_CLEAR_KEEPZ;
 281:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 282:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CON = (uint32_t) MOTOR_LIB_CIRCULAR_MODE +
 283:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_VECTORING_MODE +
 284:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_CORDIC_AUTO_START +
 285:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_UNSIGNED_X_RESULT +
 286:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_MPS_DIVBY2;
 287:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 288:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /*Loading CORDX,CORDY and CORDZ Registers*/
 289:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CORDZ = (((uint32_t)0 << MATH_CORDZ_DATA_Pos) & ((uint32_t)MATH_CORDZ_DATA_Msk)) |
 290:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (MATH->CORDZ & ((uint32_t)~((uint32_t)MATH_CORDZ_DATA_Msk)));
 291:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 292:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CORDY = (((uint32_t)y << MATH_CORDY_DATA_Pos) & ((uint32_t)MATH_CORDY_DATA_Msk)) |
 293:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (MATH->CORDY & ((uint32_t)~((uint32_t)MATH_CORDY_DATA_Msk)));
 294:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 295:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CORDX = (((uint32_t)x << MATH_CORDX_DATA_Pos) & ((uint32_t)MATH_CORDX_DATA_Msk)) |
 296:../Dave/Generated/MOTOR_LIB/motor_lib.c ****              (MATH->CORDX & ((uint32_t)~((uint32_t)MATH_CORDX_DATA_Msk)));
 297:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 298:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   while(( MATH->STATC & 0x1U )== 1U)
 299:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 300:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /*Checking for CORIDC Busy Bit*/
 301:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 302:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /* Return the Amplitude */
 303:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   resultant_magnitude = (uint32_t)((MATH->CORRX * MOTOR_LIB_MPS_DIV2)>> MOTOR_LIB_CORRX_RESULT_POSS
 304:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   resultant_magnitude = (uint32_t)((resultant_magnitude * MOTOR_LIB_INV_KCORDIC)>> MOTOR_LIB_SHIFT8
 305:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   return (resultant_magnitude);
 306:../Dave/Generated/MOTOR_LIB/motor_lib.c **** }
 307:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 308:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**
 309:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * This function is the implementation of finding the magnitude of the vector.(sqrt(x^2-y^2))
 310:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  */
 311:../Dave/Generated/MOTOR_LIB/motor_lib.c **** uint32_t MOTOR_LIB_ResultantMagnitudeHyperbolic(int32_t x,int32_t y)
 312:../Dave/Generated/MOTOR_LIB/motor_lib.c **** {
 313:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   uint32_t resultant_magnitude;
 314:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /*Clearing previous values of CORDX,CORDY and CORDZ Registers*/
 315:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->STATC = (uint32_t) MOTOR_LIB_CLEAR_KEEPX +
 316:../Dave/Generated/MOTOR_LIB/motor_lib.c ****                 (uint32_t) MOTOR_LIB_CLEAR_KEEPY +
 317:../Dave/Generated/MOTOR_LIB/motor_lib.c ****                 (uint32_t) MOTOR_LIB_CLEAR_KEEPZ;
 318:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 319:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CON = (uint32_t) MOTOR_LIB_HYPERBOLIC_MODE +
 320:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_VECTORING_MODE +
 321:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_CORDIC_AUTO_START +
 322:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_SIGNED_X_RESULT +
 323:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (uint32_t) MOTOR_LIB_MPS_DIVBY2;
 324:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 325:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /*Loading CORDX,CORDY and CORDZ Registers*/
 326:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CORDZ = (((uint32_t)0 << MATH_CORDZ_DATA_Pos) & ((uint32_t)MATH_CORDZ_DATA_Msk)) |
 327:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (MATH->CORDZ & ((uint32_t)~((uint32_t)MATH_CORDZ_DATA_Msk)));
 328:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 329:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CORDY = (((uint32_t)y << MATH_CORDY_DATA_Pos) & ((uint32_t)MATH_CORDY_DATA_Msk)) |
 330:../Dave/Generated/MOTOR_LIB/motor_lib.c ****               (MATH->CORDY & ((uint32_t)~((uint32_t)MATH_CORDY_DATA_Msk)));
 331:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 332:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   MATH->CORDX = (((uint32_t)x << MATH_CORDX_DATA_Pos) & ((uint32_t)MATH_CORDX_DATA_Msk)) |
 333:../Dave/Generated/MOTOR_LIB/motor_lib.c ****              (MATH->CORDX & ((uint32_t)~((uint32_t)MATH_CORDX_DATA_Msk)));
 334:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 335:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   while(( MATH->STATC & 0x1U )== 1U)
 336:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 337:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /*Checking for CORIDC Busy Bit*/
 338:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 339:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /* Return only the Magnitude */
 340:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   resultant_magnitude = (uint32_t)((MATH->CORRX * MOTOR_LIB_MPS_DIV2)>> MOTOR_LIB_CORRX_RESULT_POSS
 341:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   resultant_magnitude = (uint32_t)((resultant_magnitude * MOTOR_LIB_INV_KCORDIC_HYPERBOLIC)>> MOTOR
 342:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   return (resultant_magnitude);
 343:../Dave/Generated/MOTOR_LIB/motor_lib.c **** }
 344:../Dave/Generated/MOTOR_LIB/motor_lib.c **** #else
 345:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 346:../Dave/Generated/MOTOR_LIB/motor_lib.c **** uint32_t MOTOR_LIB_Car2Pol(int32_t x,int32_t y, int16_t *angle)
 347:../Dave/Generated/MOTOR_LIB/motor_lib.c **** {
 247              	 .loc 2 347 0
 248              	 .cfi_startproc
 249              	 
 250              	 
 251              	 
 252 0000 80B4     	 push {r7}
 253              	.LCFI18:
 254              	 .cfi_def_cfa_offset 4
 255              	 .cfi_offset 7,-4
 256 0002 8FB0     	 sub sp,sp,#60
 257              	.LCFI19:
 258              	 .cfi_def_cfa_offset 64
 259 0004 00AF     	 add r7,sp,#0
 260              	.LCFI20:
 261              	 .cfi_def_cfa_register 7
 262 0006 F860     	 str r0,[r7,#12]
 263 0008 B960     	 str r1,[r7,#8]
 264 000a 7A60     	 str r2,[r7,#4]
 348:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   uint8_t cordic_count;
 349:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   int32_t dx,flag = 0, temp_angle = 0,cord_y = y,cord_x = x,temp_cordic_scale,return_val;
 265              	 .loc 2 349 0
 266 000c 0023     	 movs r3,#0
 267 000e 3B63     	 str r3,[r7,#48]
 268 0010 0023     	 movs r3,#0
 269 0012 FB62     	 str r3,[r7,#44]
 270 0014 BB68     	 ldr r3,[r7,#8]
 271 0016 BB62     	 str r3,[r7,#40]
 272 0018 FB68     	 ldr r3,[r7,#12]
 273 001a 7B62     	 str r3,[r7,#36]
 350:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   uint32_t temp_cordic_s;
 351:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   if (cord_x < 0)
 274              	 .loc 2 351 0
 275 001c 7B6A     	 ldr r3,[r7,#36]
 276 001e 002B     	 cmp r3,#0
 277 0020 04DA     	 bge .L13
 352:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 353:../Dave/Generated/MOTOR_LIB/motor_lib.c ****      cord_x = (-cord_x);
 278              	 .loc 2 353 0
 279 0022 7B6A     	 ldr r3,[r7,#36]
 280 0024 5B42     	 negs r3,r3
 281 0026 7B62     	 str r3,[r7,#36]
 354:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     flag = 1;
 282              	 .loc 2 354 0
 283 0028 0123     	 movs r3,#1
 284 002a 3B63     	 str r3,[r7,#48]
 285              	.L13:
 355:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 356:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 357:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   for (cordic_count = 0U; cordic_count < MOTOR_LIB_CORDIC_ITERATIONS; cordic_count++)
 286              	 .loc 2 357 0
 287 002c 0023     	 movs r3,#0
 288 002e 87F83730 	 strb r3,[r7,#55]
 289 0032 3BE0     	 b .L14
 290              	.L17:
 358:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 359:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     temp_cordic_s = ((uint32_t)1U<< cordic_count);
 291              	 .loc 2 359 0
 292 0034 97F83730 	 ldrb r3,[r7,#55]
 293 0038 0122     	 movs r2,#1
 294 003a 02FA03F3 	 lsl r3,r2,r3
 295 003e 3B62     	 str r3,[r7,#32]
 360:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     temp_cordic_scale =(int32_t)temp_cordic_s;
 296              	 .loc 2 360 0
 297 0040 3B6A     	 ldr r3,[r7,#32]
 298 0042 FB61     	 str r3,[r7,#28]
 361:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     dx = cord_x / temp_cordic_scale;
 299              	 .loc 2 361 0
 300 0044 7A6A     	 ldr r2,[r7,#36]
 301 0046 FB69     	 ldr r3,[r7,#28]
 302 0048 92FBF3F3 	 sdiv r3,r2,r3
 303 004c BB61     	 str r3,[r7,#24]
 362:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     if ( cord_y > 0 )
 304              	 .loc 2 362 0
 305 004e BB6A     	 ldr r3,[r7,#40]
 306 0050 002B     	 cmp r3,#0
 307 0052 13DD     	 ble .L15
 363:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     {
 364:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_x += (cord_y / temp_cordic_scale);
 308              	 .loc 2 364 0
 309 0054 BA6A     	 ldr r2,[r7,#40]
 310 0056 FB69     	 ldr r3,[r7,#28]
 311 0058 92FBF3F3 	 sdiv r3,r2,r3
 312 005c 7A6A     	 ldr r2,[r7,#36]
 313 005e 1344     	 add r3,r3,r2
 314 0060 7B62     	 str r3,[r7,#36]
 365:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_y -= dx;
 315              	 .loc 2 365 0
 316 0062 BA6A     	 ldr r2,[r7,#40]
 317 0064 BB69     	 ldr r3,[r7,#24]
 318 0066 D31A     	 subs r3,r2,r3
 319 0068 BB62     	 str r3,[r7,#40]
 366:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       temp_angle -= MOTOR_LIB_E[cordic_count];
 320              	 .loc 2 366 0
 321 006a 97F83730 	 ldrb r3,[r7,#55]
 322 006e 2A4A     	 ldr r2,.L21
 323 0070 52F82330 	 ldr r3,[r2,r3,lsl#2]
 324 0074 FA6A     	 ldr r2,[r7,#44]
 325 0076 D31A     	 subs r3,r2,r3
 326 0078 FB62     	 str r3,[r7,#44]
 327 007a 12E0     	 b .L16
 328              	.L15:
 367:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     }
 368:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     else
 369:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     {
 370:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_x -= (cord_y / temp_cordic_scale);
 329              	 .loc 2 370 0
 330 007c BA6A     	 ldr r2,[r7,#40]
 331 007e FB69     	 ldr r3,[r7,#28]
 332 0080 92FBF3F3 	 sdiv r3,r2,r3
 333 0084 7A6A     	 ldr r2,[r7,#36]
 334 0086 D31A     	 subs r3,r2,r3
 335 0088 7B62     	 str r3,[r7,#36]
 371:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_y += dx;
 336              	 .loc 2 371 0
 337 008a BA6A     	 ldr r2,[r7,#40]
 338 008c BB69     	 ldr r3,[r7,#24]
 339 008e 1344     	 add r3,r3,r2
 340 0090 BB62     	 str r3,[r7,#40]
 372:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       temp_angle += MOTOR_LIB_E[cordic_count];
 341              	 .loc 2 372 0
 342 0092 97F83730 	 ldrb r3,[r7,#55]
 343 0096 204A     	 ldr r2,.L21
 344 0098 52F82330 	 ldr r3,[r2,r3,lsl#2]
 345 009c FA6A     	 ldr r2,[r7,#44]
 346 009e 1344     	 add r3,r3,r2
 347 00a0 FB62     	 str r3,[r7,#44]
 348              	.L16:
 357:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 349              	 .loc 2 357 0 discriminator 2
 350 00a2 97F83730 	 ldrb r3,[r7,#55]
 351 00a6 0133     	 adds r3,r3,#1
 352 00a8 87F83730 	 strb r3,[r7,#55]
 353              	.L14:
 357:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 354              	 .loc 2 357 0 is_stmt 0 discriminator 1
 355 00ac 97F83730 	 ldrb r3,[r7,#55]
 356 00b0 0E2B     	 cmp r3,#14
 357 00b2 BFD9     	 bls .L17
 373:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     }
 374:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 375:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   if ( flag > 0)
 358              	 .loc 2 375 0 is_stmt 1
 359 00b4 3B6B     	 ldr r3,[r7,#48]
 360 00b6 002B     	 cmp r3,#0
 361 00b8 0DDD     	 ble .L18
 376:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 377:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     *angle = (int16_t)((temp_angle + (int32_t)0x80000000)/(int32_t)MOTOR_LIB_2POW16);
 362              	 .loc 2 377 0
 363 00ba FB6A     	 ldr r3,[r7,#44]
 364 00bc 03F10043 	 add r3,r3,#-2147483648
 365 00c0 164A     	 ldr r2,.L21+4
 366 00c2 82FB0312 	 smull r1,r2,r2,r3
 367 00c6 1A44     	 add r2,r2,r3
 368 00c8 D213     	 asrs r2,r2,#15
 369 00ca DB17     	 asrs r3,r3,#31
 370 00cc D31A     	 subs r3,r2,r3
 371 00ce 9AB2     	 uxth r2,r3
 372 00d0 7B68     	 ldr r3,[r7,#4]
 373 00d2 1A80     	 strh r2,[r3]
 374 00d4 0BE0     	 b .L19
 375              	.L18:
 378:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 379:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   else
 380:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 381:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     *angle = (int16_t)((-temp_angle)/(int32_t)MOTOR_LIB_2POW16);
 376              	 .loc 2 381 0
 377 00d6 FB6A     	 ldr r3,[r7,#44]
 378 00d8 5B42     	 negs r3,r3
 379 00da 104A     	 ldr r2,.L21+4
 380 00dc 82FB0312 	 smull r1,r2,r2,r3
 381 00e0 1A44     	 add r2,r2,r3
 382 00e2 D213     	 asrs r2,r2,#15
 383 00e4 DB17     	 asrs r3,r3,#31
 384 00e6 D31A     	 subs r3,r2,r3
 385 00e8 9AB2     	 uxth r2,r3
 386 00ea 7B68     	 ldr r3,[r7,#4]
 387 00ec 1A80     	 strh r2,[r3]
 388              	.L19:
 382:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 383:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   return_val = (int32_t)((cord_x * MOTOR_LIB_INV_KCORDIC)/ MOTOR_LIB_AMPSCALE);
 389              	 .loc 2 383 0
 390 00ee 7A6A     	 ldr r2,[r7,#36]
 391 00f0 1346     	 mov r3,r2
 392 00f2 9B00     	 lsls r3,r3,#2
 393 00f4 1344     	 add r3,r3,r2
 394 00f6 5A01     	 lsls r2,r3,#5
 395 00f8 D31A     	 subs r3,r2,r3
 396 00fa 094A     	 ldr r2,.L21+8
 397 00fc 82FB0312 	 smull r1,r2,r2,r3
 398 0100 1A44     	 add r2,r2,r3
 399 0102 D211     	 asrs r2,r2,#7
 400 0104 DB17     	 asrs r3,r3,#31
 401 0106 D31A     	 subs r3,r2,r3
 402 0108 7B61     	 str r3,[r7,#20]
 384:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   return (uint32_t)(return_val);
 403              	 .loc 2 384 0
 404 010a 7B69     	 ldr r3,[r7,#20]
 385:../Dave/Generated/MOTOR_LIB/motor_lib.c **** }
 405              	 .loc 2 385 0
 406 010c 1846     	 mov r0,r3
 407 010e 3C37     	 adds r7,r7,#60
 408              	.LCFI21:
 409              	 .cfi_def_cfa_offset 4
 410 0110 BD46     	 mov sp,r7
 411              	.LCFI22:
 412              	 .cfi_def_cfa_register 13
 413              	 
 414 0112 5DF8047B 	 ldr r7,[sp],#4
 415              	.LCFI23:
 416              	 .cfi_restore 7
 417              	 .cfi_def_cfa_offset 0
 418 0116 7047     	 bx lr
 419              	.L22:
 420              	 .align 2
 421              	.L21:
 422 0118 00000000 	 .word MOTOR_LIB_E
 423 011c 01800080 	 .word -2147450879
 424 0120 81808080 	 .word -2139062143
 425              	 .cfi_endproc
 426              	.LFE132:
 428              	 .section .text.MOTOR_LIB_ResultantMagnitudeCircular,"ax",%progbits
 429              	 .align 2
 430              	 .global MOTOR_LIB_ResultantMagnitudeCircular
 431              	 .thumb
 432              	 .thumb_func
 434              	MOTOR_LIB_ResultantMagnitudeCircular:
 435              	.LFB133:
 386:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 387:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**
 388:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * This function returns the magnitude of resultant vector in circular mode.(sqrt(x^2+y^2))
 389:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  */
 390:../Dave/Generated/MOTOR_LIB/motor_lib.c **** uint32_t MOTOR_LIB_ResultantMagnitudeCircular(int32_t x,int32_t y)
 391:../Dave/Generated/MOTOR_LIB/motor_lib.c **** {
 436              	 .loc 2 391 0
 437              	 .cfi_startproc
 438              	 
 439              	 
 440              	 
 441 0000 80B4     	 push {r7}
 442              	.LCFI24:
 443              	 .cfi_def_cfa_offset 4
 444              	 .cfi_offset 7,-4
 445 0002 8BB0     	 sub sp,sp,#44
 446              	.LCFI25:
 447              	 .cfi_def_cfa_offset 48
 448 0004 00AF     	 add r7,sp,#0
 449              	.LCFI26:
 450              	 .cfi_def_cfa_register 7
 451 0006 7860     	 str r0,[r7,#4]
 452 0008 3960     	 str r1,[r7]
 392:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   uint8_t cordic_count;
 393:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   int32_t dx, cord_y = y,cord_x = x,temp_cordic_scale,return_val;
 453              	 .loc 2 393 0
 454 000a 3B68     	 ldr r3,[r7]
 455 000c 3B62     	 str r3,[r7,#32]
 456 000e 7B68     	 ldr r3,[r7,#4]
 457 0010 FB61     	 str r3,[r7,#28]
 394:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   uint32_t temp_cordic_s;
 395:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   if (cord_x < 0)
 458              	 .loc 2 395 0
 459 0012 FB69     	 ldr r3,[r7,#28]
 460 0014 002B     	 cmp r3,#0
 461 0016 02DA     	 bge .L24
 396:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 397:../Dave/Generated/MOTOR_LIB/motor_lib.c ****      cord_x = (-cord_x);
 462              	 .loc 2 397 0
 463 0018 FB69     	 ldr r3,[r7,#28]
 464 001a 5B42     	 negs r3,r3
 465 001c FB61     	 str r3,[r7,#28]
 466              	.L24:
 398:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 399:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 400:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   for (cordic_count = 0U; cordic_count < MOTOR_LIB_CORDIC_ITERATIONS; cordic_count++)
 467              	 .loc 2 400 0
 468 001e 0023     	 movs r3,#0
 469 0020 87F82730 	 strb r3,[r7,#39]
 470 0024 2BE0     	 b .L25
 471              	.L28:
 401:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 402:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     temp_cordic_s = ((uint32_t)1U<< cordic_count);
 472              	 .loc 2 402 0
 473 0026 97F82730 	 ldrb r3,[r7,#39]
 474 002a 0122     	 movs r2,#1
 475 002c 02FA03F3 	 lsl r3,r2,r3
 476 0030 BB61     	 str r3,[r7,#24]
 403:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     temp_cordic_scale =(int32_t)temp_cordic_s;
 477              	 .loc 2 403 0
 478 0032 BB69     	 ldr r3,[r7,#24]
 479 0034 7B61     	 str r3,[r7,#20]
 404:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     dx = cord_x / temp_cordic_scale;
 480              	 .loc 2 404 0
 481 0036 FA69     	 ldr r2,[r7,#28]
 482 0038 7B69     	 ldr r3,[r7,#20]
 483 003a 92FBF3F3 	 sdiv r3,r2,r3
 484 003e 3B61     	 str r3,[r7,#16]
 405:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     if ( cord_y > 0 )
 485              	 .loc 2 405 0
 486 0040 3B6A     	 ldr r3,[r7,#32]
 487 0042 002B     	 cmp r3,#0
 488 0044 0BDD     	 ble .L26
 406:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     {
 407:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_x += (cord_y / temp_cordic_scale);
 489              	 .loc 2 407 0
 490 0046 3A6A     	 ldr r2,[r7,#32]
 491 0048 7B69     	 ldr r3,[r7,#20]
 492 004a 92FBF3F3 	 sdiv r3,r2,r3
 493 004e FA69     	 ldr r2,[r7,#28]
 494 0050 1344     	 add r3,r3,r2
 495 0052 FB61     	 str r3,[r7,#28]
 408:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_y -= dx;
 496              	 .loc 2 408 0
 497 0054 3A6A     	 ldr r2,[r7,#32]
 498 0056 3B69     	 ldr r3,[r7,#16]
 499 0058 D31A     	 subs r3,r2,r3
 500 005a 3B62     	 str r3,[r7,#32]
 501 005c 0AE0     	 b .L27
 502              	.L26:
 409:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     }
 410:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     else
 411:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     {
 412:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_x -= (cord_y / temp_cordic_scale);
 503              	 .loc 2 412 0
 504 005e 3A6A     	 ldr r2,[r7,#32]
 505 0060 7B69     	 ldr r3,[r7,#20]
 506 0062 92FBF3F3 	 sdiv r3,r2,r3
 507 0066 FA69     	 ldr r2,[r7,#28]
 508 0068 D31A     	 subs r3,r2,r3
 509 006a FB61     	 str r3,[r7,#28]
 413:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_y += dx;
 510              	 .loc 2 413 0
 511 006c 3A6A     	 ldr r2,[r7,#32]
 512 006e 3B69     	 ldr r3,[r7,#16]
 513 0070 1344     	 add r3,r3,r2
 514 0072 3B62     	 str r3,[r7,#32]
 515              	.L27:
 400:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 516              	 .loc 2 400 0 discriminator 2
 517 0074 97F82730 	 ldrb r3,[r7,#39]
 518 0078 0133     	 adds r3,r3,#1
 519 007a 87F82730 	 strb r3,[r7,#39]
 520              	.L25:
 400:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 521              	 .loc 2 400 0 is_stmt 0 discriminator 1
 522 007e 97F82730 	 ldrb r3,[r7,#39]
 523 0082 0E2B     	 cmp r3,#14
 524 0084 CFD9     	 bls .L28
 414:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     }
 415:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 416:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 417:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   return_val = (int32_t)((cord_x * MOTOR_LIB_INV_KCORDIC)/ MOTOR_LIB_AMPSCALE);
 525              	 .loc 2 417 0 is_stmt 1
 526 0086 FA69     	 ldr r2,[r7,#28]
 527 0088 1346     	 mov r3,r2
 528 008a 9B00     	 lsls r3,r3,#2
 529 008c 1344     	 add r3,r3,r2
 530 008e 5A01     	 lsls r2,r3,#5
 531 0090 D31A     	 subs r3,r2,r3
 532 0092 074A     	 ldr r2,.L30
 533 0094 82FB0312 	 smull r1,r2,r2,r3
 534 0098 1A44     	 add r2,r2,r3
 535 009a D211     	 asrs r2,r2,#7
 536 009c DB17     	 asrs r3,r3,#31
 537 009e D31A     	 subs r3,r2,r3
 538 00a0 FB60     	 str r3,[r7,#12]
 418:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   return (uint32_t)(return_val);
 539              	 .loc 2 418 0
 540 00a2 FB68     	 ldr r3,[r7,#12]
 419:../Dave/Generated/MOTOR_LIB/motor_lib.c **** }
 541              	 .loc 2 419 0
 542 00a4 1846     	 mov r0,r3
 543 00a6 2C37     	 adds r7,r7,#44
 544              	.LCFI27:
 545              	 .cfi_def_cfa_offset 4
 546 00a8 BD46     	 mov sp,r7
 547              	.LCFI28:
 548              	 .cfi_def_cfa_register 13
 549              	 
 550 00aa 5DF8047B 	 ldr r7,[sp],#4
 551              	.LCFI29:
 552              	 .cfi_restore 7
 553              	 .cfi_def_cfa_offset 0
 554 00ae 7047     	 bx lr
 555              	.L31:
 556              	 .align 2
 557              	.L30:
 558 00b0 81808080 	 .word -2139062143
 559              	 .cfi_endproc
 560              	.LFE133:
 562              	 .section .text.MOTOR_LIB_ResultantMagnitudeHyperbolic,"ax",%progbits
 563              	 .align 2
 564              	 .global MOTOR_LIB_ResultantMagnitudeHyperbolic
 565              	 .thumb
 566              	 .thumb_func
 568              	MOTOR_LIB_ResultantMagnitudeHyperbolic:
 569              	.LFB134:
 420:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 421:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**
 422:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * This function is the implementation of finding the magnitude of the vector in hyperbolic mode.(s
 423:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * x should be greater than y
 424:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  */
 425:../Dave/Generated/MOTOR_LIB/motor_lib.c **** uint32_t MOTOR_LIB_ResultantMagnitudeHyperbolic(int32_t x,int32_t y)
 426:../Dave/Generated/MOTOR_LIB/motor_lib.c **** {
 570              	 .loc 2 426 0
 571              	 .cfi_startproc
 572              	 
 573              	 
 574              	 
 575 0000 80B4     	 push {r7}
 576              	.LCFI30:
 577              	 .cfi_def_cfa_offset 4
 578              	 .cfi_offset 7,-4
 579 0002 8BB0     	 sub sp,sp,#44
 580              	.LCFI31:
 581              	 .cfi_def_cfa_offset 48
 582 0004 00AF     	 add r7,sp,#0
 583              	.LCFI32:
 584              	 .cfi_def_cfa_register 7
 585 0006 7860     	 str r0,[r7,#4]
 586 0008 3960     	 str r1,[r7]
 427:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   uint8_t cordic_count,repeated_iteration_count;
 428:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   int32_t dx,dy, cord_y = y,cord_x = x,temp_cordic_scale,return_val;
 587              	 .loc 2 428 0
 588 000a 3B68     	 ldr r3,[r7]
 589 000c 3B62     	 str r3,[r7,#32]
 590 000e 7B68     	 ldr r3,[r7,#4]
 591 0010 FB61     	 str r3,[r7,#28]
 429:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   uint32_t temp_cordic_s;
 430:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /* Used for the repeated (3*repeated_iteration_count + 1) iteration steps */
 431:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   repeated_iteration_count = 4U;
 592              	 .loc 2 431 0
 593 0012 0423     	 movs r3,#4
 594 0014 87F82630 	 strb r3,[r7,#38]
 432:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 433:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   if (cord_x < 0)
 595              	 .loc 2 433 0
 596 0018 FB69     	 ldr r3,[r7,#28]
 597 001a 002B     	 cmp r3,#0
 598 001c 02DA     	 bge .L33
 434:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 435:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     cord_x = (-cord_x);
 599              	 .loc 2 435 0
 600 001e FB69     	 ldr r3,[r7,#28]
 601 0020 5B42     	 negs r3,r3
 602 0022 FB61     	 str r3,[r7,#28]
 603              	.L33:
 436:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 437:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 438:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   for (cordic_count = 1U; cordic_count < MOTOR_LIB_CORDIC_ITERATIONS; cordic_count++)
 604              	 .loc 2 438 0
 605 0024 0123     	 movs r3,#1
 606 0026 87F82730 	 strb r3,[r7,#39]
 607 002a 57E0     	 b .L34
 608              	.L40:
 439:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 440:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     temp_cordic_s = ((uint32_t)1U<< cordic_count);
 609              	 .loc 2 440 0
 610 002c 97F82730 	 ldrb r3,[r7,#39]
 611 0030 0122     	 movs r2,#1
 612 0032 02FA03F3 	 lsl r3,r2,r3
 613 0036 BB61     	 str r3,[r7,#24]
 441:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     temp_cordic_scale =(int32_t)temp_cordic_s;
 614              	 .loc 2 441 0
 615 0038 BB69     	 ldr r3,[r7,#24]
 616 003a 7B61     	 str r3,[r7,#20]
 442:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     dx = cord_x / temp_cordic_scale;
 617              	 .loc 2 442 0
 618 003c FA69     	 ldr r2,[r7,#28]
 619 003e 7B69     	 ldr r3,[r7,#20]
 620 0040 92FBF3F3 	 sdiv r3,r2,r3
 621 0044 3B61     	 str r3,[r7,#16]
 443:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     dy = cord_y / temp_cordic_scale;
 622              	 .loc 2 443 0
 623 0046 3A6A     	 ldr r2,[r7,#32]
 624 0048 7B69     	 ldr r3,[r7,#20]
 625 004a 92FBF3F3 	 sdiv r3,r2,r3
 626 004e FB60     	 str r3,[r7,#12]
 444:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     if ( cord_y > 0 )
 627              	 .loc 2 444 0
 628 0050 3B6A     	 ldr r3,[r7,#32]
 629 0052 002B     	 cmp r3,#0
 630 0054 08DD     	 ble .L35
 445:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     {
 446:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_x -= dy;
 631              	 .loc 2 446 0
 632 0056 FA69     	 ldr r2,[r7,#28]
 633 0058 FB68     	 ldr r3,[r7,#12]
 634 005a D31A     	 subs r3,r2,r3
 635 005c FB61     	 str r3,[r7,#28]
 447:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_y -= dx;
 636              	 .loc 2 447 0
 637 005e 3A6A     	 ldr r2,[r7,#32]
 638 0060 3B69     	 ldr r3,[r7,#16]
 639 0062 D31A     	 subs r3,r2,r3
 640 0064 3B62     	 str r3,[r7,#32]
 641 0066 07E0     	 b .L36
 642              	.L35:
 448:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     }
 449:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     else
 450:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     {
 451:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_x += dy;
 643              	 .loc 2 451 0
 644 0068 FA69     	 ldr r2,[r7,#28]
 645 006a FB68     	 ldr r3,[r7,#12]
 646 006c 1344     	 add r3,r3,r2
 647 006e FB61     	 str r3,[r7,#28]
 452:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_y += dx;
 648              	 .loc 2 452 0
 649 0070 3A6A     	 ldr r2,[r7,#32]
 650 0072 3B69     	 ldr r3,[r7,#16]
 651 0074 1344     	 add r3,r3,r2
 652 0076 3B62     	 str r3,[r7,#32]
 653              	.L36:
 453:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     }
 454:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 455:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     if (cordic_count == repeated_iteration_count)
 654              	 .loc 2 455 0
 655 0078 97F82720 	 ldrb r2,[r7,#39]
 656 007c 97F82630 	 ldrb r3,[r7,#38]
 657 0080 9A42     	 cmp r2,r3
 658 0082 26D1     	 bne .L37
 456:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     {
 457:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       dx = cord_x / temp_cordic_scale;
 659              	 .loc 2 457 0
 660 0084 FA69     	 ldr r2,[r7,#28]
 661 0086 7B69     	 ldr r3,[r7,#20]
 662 0088 92FBF3F3 	 sdiv r3,r2,r3
 663 008c 3B61     	 str r3,[r7,#16]
 458:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       dy = cord_y / temp_cordic_scale;
 664              	 .loc 2 458 0
 665 008e 3A6A     	 ldr r2,[r7,#32]
 666 0090 7B69     	 ldr r3,[r7,#20]
 667 0092 92FBF3F3 	 sdiv r3,r2,r3
 668 0096 FB60     	 str r3,[r7,#12]
 459:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       if ( cord_y > 0 )
 669              	 .loc 2 459 0
 670 0098 3B6A     	 ldr r3,[r7,#32]
 671 009a 002B     	 cmp r3,#0
 672 009c 08DD     	 ble .L38
 460:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       {
 461:../Dave/Generated/MOTOR_LIB/motor_lib.c ****         cord_x -= dy;
 673              	 .loc 2 461 0
 674 009e FA69     	 ldr r2,[r7,#28]
 675 00a0 FB68     	 ldr r3,[r7,#12]
 676 00a2 D31A     	 subs r3,r2,r3
 677 00a4 FB61     	 str r3,[r7,#28]
 462:../Dave/Generated/MOTOR_LIB/motor_lib.c ****         cord_y -= dx;
 678              	 .loc 2 462 0
 679 00a6 3A6A     	 ldr r2,[r7,#32]
 680 00a8 3B69     	 ldr r3,[r7,#16]
 681 00aa D31A     	 subs r3,r2,r3
 682 00ac 3B62     	 str r3,[r7,#32]
 683 00ae 07E0     	 b .L39
 684              	.L38:
 463:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       }
 464:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       else
 465:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       {
 466:../Dave/Generated/MOTOR_LIB/motor_lib.c ****         cord_x += dy;
 685              	 .loc 2 466 0
 686 00b0 FA69     	 ldr r2,[r7,#28]
 687 00b2 FB68     	 ldr r3,[r7,#12]
 688 00b4 1344     	 add r3,r3,r2
 689 00b6 FB61     	 str r3,[r7,#28]
 467:../Dave/Generated/MOTOR_LIB/motor_lib.c ****         cord_y += dx;
 690              	 .loc 2 467 0
 691 00b8 3A6A     	 ldr r2,[r7,#32]
 692 00ba 3B69     	 ldr r3,[r7,#16]
 693 00bc 1344     	 add r3,r3,r2
 694 00be 3B62     	 str r3,[r7,#32]
 695              	.L39:
 468:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       }
 469:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       repeated_iteration_count = (uint8_t)((3U * repeated_iteration_count) + 1U);
 696              	 .loc 2 469 0
 697 00c0 97F82630 	 ldrb r3,[r7,#38]
 698 00c4 1A46     	 mov r2,r3
 699 00c6 5200     	 lsls r2,r2,#1
 700 00c8 1344     	 add r3,r3,r2
 701 00ca DBB2     	 uxtb r3,r3
 702 00cc 0133     	 adds r3,r3,#1
 703 00ce 87F82630 	 strb r3,[r7,#38]
 704              	.L37:
 438:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 705              	 .loc 2 438 0 discriminator 2
 706 00d2 97F82730 	 ldrb r3,[r7,#39]
 707 00d6 0133     	 adds r3,r3,#1
 708 00d8 87F82730 	 strb r3,[r7,#39]
 709              	.L34:
 438:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 710              	 .loc 2 438 0 is_stmt 0 discriminator 1
 711 00dc 97F82730 	 ldrb r3,[r7,#39]
 712 00e0 0E2B     	 cmp r3,#14
 713 00e2 A3D9     	 bls .L40
 470:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     }
 471:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 472:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   return_val = (int32_t)((cord_x * MOTOR_LIB_INV_KCORDIC_HYPERBOLIC)/ MOTOR_LIB_AMPSCALE);
 714              	 .loc 2 472 0 is_stmt 1
 715 00e4 FB69     	 ldr r3,[r7,#28]
 716 00e6 4FF49A72 	 mov r2,#308
 717 00ea 02FB03F3 	 mul r3,r2,r3
 718 00ee 074A     	 ldr r2,.L42
 719 00f0 82FB0312 	 smull r1,r2,r2,r3
 720 00f4 1A44     	 add r2,r2,r3
 721 00f6 D211     	 asrs r2,r2,#7
 722 00f8 DB17     	 asrs r3,r3,#31
 723 00fa D31A     	 subs r3,r2,r3
 724 00fc BB60     	 str r3,[r7,#8]
 473:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   return ((uint32_t)return_val);
 725              	 .loc 2 473 0
 726 00fe BB68     	 ldr r3,[r7,#8]
 474:../Dave/Generated/MOTOR_LIB/motor_lib.c **** }
 727              	 .loc 2 474 0
 728 0100 1846     	 mov r0,r3
 729 0102 2C37     	 adds r7,r7,#44
 730              	.LCFI33:
 731              	 .cfi_def_cfa_offset 4
 732 0104 BD46     	 mov sp,r7
 733              	.LCFI34:
 734              	 .cfi_def_cfa_register 13
 735              	 
 736 0106 5DF8047B 	 ldr r7,[sp],#4
 737              	.LCFI35:
 738              	 .cfi_restore 7
 739              	 .cfi_def_cfa_offset 0
 740 010a 7047     	 bx lr
 741              	.L43:
 742              	 .align 2
 743              	.L42:
 744 010c 81808080 	 .word -2139062143
 745              	 .cfi_endproc
 746              	.LFE134:
 748              	 .section .text.MOTOR_LIB_Pol2Car,"ax",%progbits
 749              	 .align 2
 750              	 .global MOTOR_LIB_Pol2Car
 751              	 .thumb
 752              	 .thumb_func
 754              	MOTOR_LIB_Pol2Car:
 755              	.LFB135:
 475:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 476:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**
 477:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * This function is the implementation of Polar to cartesian Transformation.
 478:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  */
 479:../Dave/Generated/MOTOR_LIB/motor_lib.c **** int32_t MOTOR_LIB_Pol2Car(int16_t angle,uint32_t amplitude, int32_t *x)
 480:../Dave/Generated/MOTOR_LIB/motor_lib.c **** {
 756              	 .loc 2 480 0
 757              	 .cfi_startproc
 758              	 
 759              	 
 760 0000 80B5     	 push {r7,lr}
 761              	.LCFI36:
 762              	 .cfi_def_cfa_offset 8
 763              	 .cfi_offset 7,-8
 764              	 .cfi_offset 14,-4
 765 0002 8CB0     	 sub sp,sp,#48
 766              	.LCFI37:
 767              	 .cfi_def_cfa_offset 56
 768 0004 00AF     	 add r7,sp,#0
 769              	.LCFI38:
 770              	 .cfi_def_cfa_register 7
 771 0006 0346     	 mov r3,r0
 772 0008 B960     	 str r1,[r7,#8]
 773 000a 7A60     	 str r2,[r7,#4]
 774 000c FB81     	 strh r3,[r7,#14]
 481:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   uint8_t cordic_count, flag=0U;
 775              	 .loc 2 481 0
 776 000e 0023     	 movs r3,#0
 777 0010 87F82E30 	 strb r3,[r7,#46]
 482:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   int32_t dx,temp_cordic_scale;
 483:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   int32_t cord_x = (int32_t)amplitude,cord_y=0;
 778              	 .loc 2 483 0
 779 0014 BB68     	 ldr r3,[r7,#8]
 780 0016 BB62     	 str r3,[r7,#40]
 781 0018 0023     	 movs r3,#0
 782 001a 7B62     	 str r3,[r7,#36]
 484:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   int32_t temp_angle = angle * (int32_t)MOTOR_LIB_2POW16;
 783              	 .loc 2 484 0
 784 001c B7F90E20 	 ldrsh r2,[r7,#14]
 785 0020 1346     	 mov r3,r2
 786 0022 1B04     	 lsls r3,r3,#16
 787 0024 9B1A     	 subs r3,r3,r2
 788 0026 3B62     	 str r3,[r7,#32]
 485:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   uint32_t  temp_cordic_s;
 486:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 487:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   if (MOTOR_LIB_abs(temp_angle) > 0x40000000U)
 789              	 .loc 2 487 0
 790 0028 386A     	 ldr r0,[r7,#32]
 791 002a FFF7FEFF 	 bl MOTOR_LIB_abs
 792 002e 0346     	 mov r3,r0
 793 0030 B3F1804F 	 cmp r3,#1073741824
 794 0034 09D9     	 bls .L45
 488:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 489:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     temp_angle = (int32_t)((int32_t)0x80000000 - temp_angle);
 795              	 .loc 2 489 0
 796 0036 3B6A     	 ldr r3,[r7,#32]
 797 0038 C3F10043 	 rsb r3,r3,#-2147483648
 798 003c 3B62     	 str r3,[r7,#32]
 490:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     cord_x = -cord_x;
 799              	 .loc 2 490 0
 800 003e BB6A     	 ldr r3,[r7,#40]
 801 0040 5B42     	 negs r3,r3
 802 0042 BB62     	 str r3,[r7,#40]
 491:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     flag = 1U;
 803              	 .loc 2 491 0
 804 0044 0123     	 movs r3,#1
 805 0046 87F82E30 	 strb r3,[r7,#46]
 806              	.L45:
 492:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 493:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 494:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   for (cordic_count = 0U; cordic_count < MOTOR_LIB_CORDIC_ITERATIONS; cordic_count++)
 807              	 .loc 2 494 0
 808 004a 0023     	 movs r3,#0
 809 004c 87F82F30 	 strb r3,[r7,#47]
 810 0050 3BE0     	 b .L46
 811              	.L49:
 495:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 496:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     temp_cordic_s = ((uint32_t)1<< cordic_count);
 812              	 .loc 2 496 0
 813 0052 97F82F30 	 ldrb r3,[r7,#47]
 814 0056 0122     	 movs r2,#1
 815 0058 02FA03F3 	 lsl r3,r2,r3
 816 005c FB61     	 str r3,[r7,#28]
 497:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     temp_cordic_scale =(int32_t)temp_cordic_s;
 817              	 .loc 2 497 0
 818 005e FB69     	 ldr r3,[r7,#28]
 819 0060 BB61     	 str r3,[r7,#24]
 498:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     dx = cord_x / temp_cordic_scale;
 820              	 .loc 2 498 0
 821 0062 BA6A     	 ldr r2,[r7,#40]
 822 0064 BB69     	 ldr r3,[r7,#24]
 823 0066 92FBF3F3 	 sdiv r3,r2,r3
 824 006a 7B61     	 str r3,[r7,#20]
 499:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     if (temp_angle > 0)
 825              	 .loc 2 499 0
 826 006c 3B6A     	 ldr r3,[r7,#32]
 827 006e 002B     	 cmp r3,#0
 828 0070 13DD     	 ble .L47
 500:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     {
 501:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_x -= cord_y / temp_cordic_scale;
 829              	 .loc 2 501 0
 830 0072 7A6A     	 ldr r2,[r7,#36]
 831 0074 BB69     	 ldr r3,[r7,#24]
 832 0076 92FBF3F3 	 sdiv r3,r2,r3
 833 007a BA6A     	 ldr r2,[r7,#40]
 834 007c D31A     	 subs r3,r2,r3
 835 007e BB62     	 str r3,[r7,#40]
 502:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_y += dx;
 836              	 .loc 2 502 0
 837 0080 7A6A     	 ldr r2,[r7,#36]
 838 0082 7B69     	 ldr r3,[r7,#20]
 839 0084 1344     	 add r3,r3,r2
 840 0086 7B62     	 str r3,[r7,#36]
 503:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       temp_angle -= MOTOR_LIB_E[cordic_count];
 841              	 .loc 2 503 0
 842 0088 97F82F30 	 ldrb r3,[r7,#47]
 843 008c 254A     	 ldr r2,.L52
 844 008e 52F82330 	 ldr r3,[r2,r3,lsl#2]
 845 0092 3A6A     	 ldr r2,[r7,#32]
 846 0094 D31A     	 subs r3,r2,r3
 847 0096 3B62     	 str r3,[r7,#32]
 848 0098 12E0     	 b .L48
 849              	.L47:
 504:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     }
 505:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     else
 506:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     {
 507:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_x += cord_y / temp_cordic_scale;
 850              	 .loc 2 507 0
 851 009a 7A6A     	 ldr r2,[r7,#36]
 852 009c BB69     	 ldr r3,[r7,#24]
 853 009e 92FBF3F3 	 sdiv r3,r2,r3
 854 00a2 BA6A     	 ldr r2,[r7,#40]
 855 00a4 1344     	 add r3,r3,r2
 856 00a6 BB62     	 str r3,[r7,#40]
 508:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_y -= dx;
 857              	 .loc 2 508 0
 858 00a8 7A6A     	 ldr r2,[r7,#36]
 859 00aa 7B69     	 ldr r3,[r7,#20]
 860 00ac D31A     	 subs r3,r2,r3
 861 00ae 7B62     	 str r3,[r7,#36]
 509:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       temp_angle += MOTOR_LIB_E[cordic_count];
 862              	 .loc 2 509 0
 863 00b0 97F82F30 	 ldrb r3,[r7,#47]
 864 00b4 1B4A     	 ldr r2,.L52
 865 00b6 52F82330 	 ldr r3,[r2,r3,lsl#2]
 866 00ba 3A6A     	 ldr r2,[r7,#32]
 867 00bc 1344     	 add r3,r3,r2
 868 00be 3B62     	 str r3,[r7,#32]
 869              	.L48:
 494:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 870              	 .loc 2 494 0 discriminator 2
 871 00c0 97F82F30 	 ldrb r3,[r7,#47]
 872 00c4 0133     	 adds r3,r3,#1
 873 00c6 87F82F30 	 strb r3,[r7,#47]
 874              	.L46:
 494:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 875              	 .loc 2 494 0 is_stmt 0 discriminator 1
 876 00ca 97F82F30 	 ldrb r3,[r7,#47]
 877 00ce 0E2B     	 cmp r3,#14
 878 00d0 BFD9     	 bls .L49
 510:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     }
 511:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 512:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 513:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   if ( flag > 0U)
 879              	 .loc 2 513 0 is_stmt 1
 880 00d2 97F82E30 	 ldrb r3,[r7,#46]
 881 00d6 002B     	 cmp r3,#0
 882 00d8 02D0     	 beq .L50
 514:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 515:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     cord_y = (-cord_y);
 883              	 .loc 2 515 0
 884 00da 7B6A     	 ldr r3,[r7,#36]
 885 00dc 5B42     	 negs r3,r3
 886 00de 7B62     	 str r3,[r7,#36]
 887              	.L50:
 516:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 517:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 518:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   cord_x = (((cord_x*MOTOR_LIB_INV_KCORDIC)/ (MOTOR_LIB_AMPSCALE)));
 888              	 .loc 2 518 0
 889 00e0 BA6A     	 ldr r2,[r7,#40]
 890 00e2 1346     	 mov r3,r2
 891 00e4 9B00     	 lsls r3,r3,#2
 892 00e6 1344     	 add r3,r3,r2
 893 00e8 5A01     	 lsls r2,r3,#5
 894 00ea D31A     	 subs r3,r2,r3
 895 00ec 0E4A     	 ldr r2,.L52+4
 896 00ee 82FB0312 	 smull r1,r2,r2,r3
 897 00f2 1A44     	 add r2,r2,r3
 898 00f4 D211     	 asrs r2,r2,#7
 899 00f6 DB17     	 asrs r3,r3,#31
 900 00f8 D31A     	 subs r3,r2,r3
 901 00fa BB62     	 str r3,[r7,#40]
 519:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 520:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   *x = cord_x;
 902              	 .loc 2 520 0
 903 00fc 7B68     	 ldr r3,[r7,#4]
 904 00fe BA6A     	 ldr r2,[r7,#40]
 905 0100 1A60     	 str r2,[r3]
 521:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   return ((cord_y*MOTOR_LIB_INV_KCORDIC)/ (MOTOR_LIB_AMPSCALE));
 906              	 .loc 2 521 0
 907 0102 7A6A     	 ldr r2,[r7,#36]
 908 0104 1346     	 mov r3,r2
 909 0106 9B00     	 lsls r3,r3,#2
 910 0108 1344     	 add r3,r3,r2
 911 010a 5A01     	 lsls r2,r3,#5
 912 010c D31A     	 subs r3,r2,r3
 913 010e 064A     	 ldr r2,.L52+4
 914 0110 82FB0312 	 smull r1,r2,r2,r3
 915 0114 1A44     	 add r2,r2,r3
 916 0116 D211     	 asrs r2,r2,#7
 917 0118 DB17     	 asrs r3,r3,#31
 918 011a D31A     	 subs r3,r2,r3
 522:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 523:../Dave/Generated/MOTOR_LIB/motor_lib.c **** }
 919              	 .loc 2 523 0
 920 011c 1846     	 mov r0,r3
 921 011e 3037     	 adds r7,r7,#48
 922              	.LCFI39:
 923              	 .cfi_def_cfa_offset 8
 924 0120 BD46     	 mov sp,r7
 925              	.LCFI40:
 926              	 .cfi_def_cfa_register 13
 927              	 
 928 0122 80BD     	 pop {r7,pc}
 929              	.L53:
 930              	 .align 2
 931              	.L52:
 932 0124 00000000 	 .word MOTOR_LIB_E
 933 0128 81808080 	 .word -2139062143
 934              	 .cfi_endproc
 935              	.LFE135:
 937              	 .section .text.MOTOR_LIB_ParkTransform,"ax",%progbits
 938              	 .align 2
 939              	 .global MOTOR_LIB_ParkTransform
 940              	 .thumb
 941              	 .thumb_func
 943              	MOTOR_LIB_ParkTransform:
 944              	.LFB136:
 524:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 525:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**
 526:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * This function is the implementation of park transform.
 527:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  */
 528:../Dave/Generated/MOTOR_LIB/motor_lib.c **** int32_t MOTOR_LIB_ParkTransform(int32_t i_alpha,int32_t i_beta,int16_t angle,int32_t *iq)
 529:../Dave/Generated/MOTOR_LIB/motor_lib.c **** {
 945              	 .loc 2 529 0
 946              	 .cfi_startproc
 947              	 
 948              	 
 949 0000 80B5     	 push {r7,lr}
 950              	.LCFI41:
 951              	 .cfi_def_cfa_offset 8
 952              	 .cfi_offset 7,-8
 953              	 .cfi_offset 14,-4
 954 0002 8CB0     	 sub sp,sp,#48
 955              	.LCFI42:
 956              	 .cfi_def_cfa_offset 56
 957 0004 00AF     	 add r7,sp,#0
 958              	.LCFI43:
 959              	 .cfi_def_cfa_register 7
 960 0006 F860     	 str r0,[r7,#12]
 961 0008 B960     	 str r1,[r7,#8]
 962 000a 3B60     	 str r3,[r7]
 963 000c 1346     	 mov r3,r2
 964 000e FB80     	 strh r3,[r7,#6]
 530:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   uint8_t cordic_count, flag=0U;
 965              	 .loc 2 530 0
 966 0010 0023     	 movs r3,#0
 967 0012 87F82E30 	 strb r3,[r7,#46]
 531:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   int32_t temp_cordic_scale,dx,cord_x =i_beta,cord_y=i_alpha;
 968              	 .loc 2 531 0
 969 0016 BB68     	 ldr r3,[r7,#8]
 970 0018 BB62     	 str r3,[r7,#40]
 971 001a FB68     	 ldr r3,[r7,#12]
 972 001c 7B62     	 str r3,[r7,#36]
 532:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   int32_t temp_angle = angle * (int32_t)MOTOR_LIB_2POW16;
 973              	 .loc 2 532 0
 974 001e B7F90620 	 ldrsh r2,[r7,#6]
 975 0022 1346     	 mov r3,r2
 976 0024 1B04     	 lsls r3,r3,#16
 977 0026 9B1A     	 subs r3,r3,r2
 978 0028 3B62     	 str r3,[r7,#32]
 533:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   uint32_t temp_cordic_s;
 534:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 535:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   if ( MOTOR_LIB_abs(temp_angle) > 0x40000000U)
 979              	 .loc 2 535 0
 980 002a 386A     	 ldr r0,[r7,#32]
 981 002c FFF7FEFF 	 bl MOTOR_LIB_abs
 982 0030 0346     	 mov r3,r0
 983 0032 B3F1804F 	 cmp r3,#1073741824
 984 0036 09D9     	 bls .L55
 536:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 537:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     temp_angle = (int32_t)((int32_t)0x80000000 - temp_angle);
 985              	 .loc 2 537 0
 986 0038 3B6A     	 ldr r3,[r7,#32]
 987 003a C3F10043 	 rsb r3,r3,#-2147483648
 988 003e 3B62     	 str r3,[r7,#32]
 538:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     cord_x = -cord_x;
 989              	 .loc 2 538 0
 990 0040 BB6A     	 ldr r3,[r7,#40]
 991 0042 5B42     	 negs r3,r3
 992 0044 BB62     	 str r3,[r7,#40]
 539:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     flag = 1U;
 993              	 .loc 2 539 0
 994 0046 0123     	 movs r3,#1
 995 0048 87F82E30 	 strb r3,[r7,#46]
 996              	.L55:
 540:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 541:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 542:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 543:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   for (cordic_count = 0U; cordic_count < MOTOR_LIB_CORDIC_ITERATIONS; cordic_count++)
 997              	 .loc 2 543 0
 998 004c 0023     	 movs r3,#0
 999 004e 87F82F30 	 strb r3,[r7,#47]
 1000 0052 3BE0     	 b .L56
 1001              	.L59:
 544:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 545:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     temp_cordic_s = ((uint32_t)1<< cordic_count);
 1002              	 .loc 2 545 0
 1003 0054 97F82F30 	 ldrb r3,[r7,#47]
 1004 0058 0122     	 movs r2,#1
 1005 005a 02FA03F3 	 lsl r3,r2,r3
 1006 005e FB61     	 str r3,[r7,#28]
 546:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     temp_cordic_scale =(int32_t)temp_cordic_s ;
 1007              	 .loc 2 546 0
 1008 0060 FB69     	 ldr r3,[r7,#28]
 1009 0062 BB61     	 str r3,[r7,#24]
 547:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     dx = cord_x / temp_cordic_scale;
 1010              	 .loc 2 547 0
 1011 0064 BA6A     	 ldr r2,[r7,#40]
 1012 0066 BB69     	 ldr r3,[r7,#24]
 1013 0068 92FBF3F3 	 sdiv r3,r2,r3
 1014 006c 7B61     	 str r3,[r7,#20]
 548:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 549:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     if (temp_angle > 0)
 1015              	 .loc 2 549 0
 1016 006e 3B6A     	 ldr r3,[r7,#32]
 1017 0070 002B     	 cmp r3,#0
 1018 0072 13DD     	 ble .L57
 550:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     {
 551:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_x -= cord_y / temp_cordic_scale;
 1019              	 .loc 2 551 0
 1020 0074 7A6A     	 ldr r2,[r7,#36]
 1021 0076 BB69     	 ldr r3,[r7,#24]
 1022 0078 92FBF3F3 	 sdiv r3,r2,r3
 1023 007c BA6A     	 ldr r2,[r7,#40]
 1024 007e D31A     	 subs r3,r2,r3
 1025 0080 BB62     	 str r3,[r7,#40]
 552:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_y += dx;
 1026              	 .loc 2 552 0
 1027 0082 7A6A     	 ldr r2,[r7,#36]
 1028 0084 7B69     	 ldr r3,[r7,#20]
 1029 0086 1344     	 add r3,r3,r2
 1030 0088 7B62     	 str r3,[r7,#36]
 553:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       temp_angle -= MOTOR_LIB_E[cordic_count];
 1031              	 .loc 2 553 0
 1032 008a 97F82F30 	 ldrb r3,[r7,#47]
 1033 008e 254A     	 ldr r2,.L62
 1034 0090 52F82330 	 ldr r3,[r2,r3,lsl#2]
 1035 0094 3A6A     	 ldr r2,[r7,#32]
 1036 0096 D31A     	 subs r3,r2,r3
 1037 0098 3B62     	 str r3,[r7,#32]
 1038 009a 12E0     	 b .L58
 1039              	.L57:
 554:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     }
 555:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     else
 556:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     {
 557:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_x += cord_y / temp_cordic_scale;
 1040              	 .loc 2 557 0
 1041 009c 7A6A     	 ldr r2,[r7,#36]
 1042 009e BB69     	 ldr r3,[r7,#24]
 1043 00a0 92FBF3F3 	 sdiv r3,r2,r3
 1044 00a4 BA6A     	 ldr r2,[r7,#40]
 1045 00a6 1344     	 add r3,r3,r2
 1046 00a8 BB62     	 str r3,[r7,#40]
 558:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_y -= dx;
 1047              	 .loc 2 558 0
 1048 00aa 7A6A     	 ldr r2,[r7,#36]
 1049 00ac 7B69     	 ldr r3,[r7,#20]
 1050 00ae D31A     	 subs r3,r2,r3
 1051 00b0 7B62     	 str r3,[r7,#36]
 559:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       temp_angle += MOTOR_LIB_E[cordic_count];
 1052              	 .loc 2 559 0
 1053 00b2 97F82F30 	 ldrb r3,[r7,#47]
 1054 00b6 1B4A     	 ldr r2,.L62
 1055 00b8 52F82330 	 ldr r3,[r2,r3,lsl#2]
 1056 00bc 3A6A     	 ldr r2,[r7,#32]
 1057 00be 1344     	 add r3,r3,r2
 1058 00c0 3B62     	 str r3,[r7,#32]
 1059              	.L58:
 543:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 1060              	 .loc 2 543 0 discriminator 2
 1061 00c2 97F82F30 	 ldrb r3,[r7,#47]
 1062 00c6 0133     	 adds r3,r3,#1
 1063 00c8 87F82F30 	 strb r3,[r7,#47]
 1064              	.L56:
 543:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 1065              	 .loc 2 543 0 is_stmt 0 discriminator 1
 1066 00cc 97F82F30 	 ldrb r3,[r7,#47]
 1067 00d0 0E2B     	 cmp r3,#14
 1068 00d2 BFD9     	 bls .L59
 560:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     }
 561:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 562:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   *iq = (int32_t)((cord_x*MOTOR_LIB_INV_KCORDIC)/ MOTOR_LIB_MPS);
 1069              	 .loc 2 562 0 is_stmt 1
 1070 00d4 BA6A     	 ldr r2,[r7,#40]
 1071 00d6 1346     	 mov r3,r2
 1072 00d8 9B00     	 lsls r3,r3,#2
 1073 00da 1344     	 add r3,r3,r2
 1074 00dc 5A01     	 lsls r2,r3,#5
 1075 00de D31A     	 subs r3,r2,r3
 1076 00e0 114A     	 ldr r2,.L62+4
 1077 00e2 82FB0312 	 smull r1,r2,r2,r3
 1078 00e6 1A44     	 add r2,r2,r3
 1079 00e8 D211     	 asrs r2,r2,#7
 1080 00ea DB17     	 asrs r3,r3,#31
 1081 00ec D21A     	 subs r2,r2,r3
 1082 00ee 3B68     	 ldr r3,[r7]
 1083 00f0 1A60     	 str r2,[r3]
 563:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   if (flag > 0U)
 1084              	 .loc 2 563 0
 1085 00f2 97F82E30 	 ldrb r3,[r7,#46]
 1086 00f6 002B     	 cmp r3,#0
 1087 00f8 02D0     	 beq .L60
 564:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 565:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     cord_y = (-cord_y);
 1088              	 .loc 2 565 0
 1089 00fa 7B6A     	 ldr r3,[r7,#36]
 1090 00fc 5B42     	 negs r3,r3
 1091 00fe 7B62     	 str r3,[r7,#36]
 1092              	.L60:
 566:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 567:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   return ((int32_t)((cord_y*MOTOR_LIB_INV_KCORDIC)/ MOTOR_LIB_MPS));
 1093              	 .loc 2 567 0
 1094 0100 7A6A     	 ldr r2,[r7,#36]
 1095 0102 1346     	 mov r3,r2
 1096 0104 9B00     	 lsls r3,r3,#2
 1097 0106 1344     	 add r3,r3,r2
 1098 0108 5A01     	 lsls r2,r3,#5
 1099 010a D31A     	 subs r3,r2,r3
 1100 010c 064A     	 ldr r2,.L62+4
 1101 010e 82FB0312 	 smull r1,r2,r2,r3
 1102 0112 1A44     	 add r2,r2,r3
 1103 0114 D211     	 asrs r2,r2,#7
 1104 0116 DB17     	 asrs r3,r3,#31
 1105 0118 D31A     	 subs r3,r2,r3
 568:../Dave/Generated/MOTOR_LIB/motor_lib.c **** }
 1106              	 .loc 2 568 0
 1107 011a 1846     	 mov r0,r3
 1108 011c 3037     	 adds r7,r7,#48
 1109              	.LCFI44:
 1110              	 .cfi_def_cfa_offset 8
 1111 011e BD46     	 mov sp,r7
 1112              	.LCFI45:
 1113              	 .cfi_def_cfa_register 13
 1114              	 
 1115 0120 80BD     	 pop {r7,pc}
 1116              	.L63:
 1117 0122 00BF     	 .align 2
 1118              	.L62:
 1119 0124 00000000 	 .word MOTOR_LIB_E
 1120 0128 81808080 	 .word -2139062143
 1121              	 .cfi_endproc
 1122              	.LFE136:
 1124              	 .section .text.MOTOR_LIB_IParkTransform,"ax",%progbits
 1125              	 .align 2
 1126              	 .global MOTOR_LIB_IParkTransform
 1127              	 .thumb
 1128              	 .thumb_func
 1130              	MOTOR_LIB_IParkTransform:
 1131              	.LFB137:
 569:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**
 570:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * This function is the implementation of Inverse park transform.
 571:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * Valpha  = k/4*(Vd*cos(Angle)- Vq*sin(Angle))
 572:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * Vbeta   = k/4*(Vd*sin(Angle)+ Vq*cos(Angle))
 573:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  */
 574:../Dave/Generated/MOTOR_LIB/motor_lib.c **** int32_t MOTOR_LIB_IParkTransform(int32_t vd,int32_t vq,int16_t angle,int32_t *v_beta)
 575:../Dave/Generated/MOTOR_LIB/motor_lib.c **** {
 1132              	 .loc 2 575 0
 1133              	 .cfi_startproc
 1134              	 
 1135              	 
 1136 0000 80B5     	 push {r7,lr}
 1137              	.LCFI46:
 1138              	 .cfi_def_cfa_offset 8
 1139              	 .cfi_offset 7,-8
 1140              	 .cfi_offset 14,-4
 1141 0002 8CB0     	 sub sp,sp,#48
 1142              	.LCFI47:
 1143              	 .cfi_def_cfa_offset 56
 1144 0004 00AF     	 add r7,sp,#0
 1145              	.LCFI48:
 1146              	 .cfi_def_cfa_register 7
 1147 0006 F860     	 str r0,[r7,#12]
 1148 0008 B960     	 str r1,[r7,#8]
 1149 000a 3B60     	 str r3,[r7]
 1150 000c 1346     	 mov r3,r2
 1151 000e FB80     	 strh r3,[r7,#6]
 576:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   uint8_t cordic_count, flag=0U;
 1152              	 .loc 2 576 0
 1153 0010 0023     	 movs r3,#0
 1154 0012 87F82E30 	 strb r3,[r7,#46]
 577:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   int32_t temp_cordic_scale,dx,cord_x =vd,cord_y=vq;
 1155              	 .loc 2 577 0
 1156 0016 FB68     	 ldr r3,[r7,#12]
 1157 0018 BB62     	 str r3,[r7,#40]
 1158 001a BB68     	 ldr r3,[r7,#8]
 1159 001c 7B62     	 str r3,[r7,#36]
 578:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   int32_t temp_angle = angle * (int32_t)MOTOR_LIB_2POW16;
 1160              	 .loc 2 578 0
 1161 001e B7F90620 	 ldrsh r2,[r7,#6]
 1162 0022 1346     	 mov r3,r2
 1163 0024 1B04     	 lsls r3,r3,#16
 1164 0026 9B1A     	 subs r3,r3,r2
 1165 0028 3B62     	 str r3,[r7,#32]
 579:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   uint32_t temp_cordic_s;
 580:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 581:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   if ( MOTOR_LIB_abs(temp_angle) > 0x40000000U)
 1166              	 .loc 2 581 0
 1167 002a 386A     	 ldr r0,[r7,#32]
 1168 002c FFF7FEFF 	 bl MOTOR_LIB_abs
 1169 0030 0346     	 mov r3,r0
 1170 0032 B3F1804F 	 cmp r3,#1073741824
 1171 0036 09D9     	 bls .L65
 582:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 583:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     temp_angle = (int32_t)((int32_t)0x80000000 - temp_angle);
 1172              	 .loc 2 583 0
 1173 0038 3B6A     	 ldr r3,[r7,#32]
 1174 003a C3F10043 	 rsb r3,r3,#-2147483648
 1175 003e 3B62     	 str r3,[r7,#32]
 584:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     cord_x = -cord_x;
 1176              	 .loc 2 584 0
 1177 0040 BB6A     	 ldr r3,[r7,#40]
 1178 0042 5B42     	 negs r3,r3
 1179 0044 BB62     	 str r3,[r7,#40]
 585:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     flag = 1U;
 1180              	 .loc 2 585 0
 1181 0046 0123     	 movs r3,#1
 1182 0048 87F82E30 	 strb r3,[r7,#46]
 1183              	.L65:
 586:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 587:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 588:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   for (cordic_count = 0U; cordic_count < MOTOR_LIB_CORDIC_ITERATIONS; cordic_count++)
 1184              	 .loc 2 588 0
 1185 004c 0023     	 movs r3,#0
 1186 004e 87F82F30 	 strb r3,[r7,#47]
 1187 0052 3BE0     	 b .L66
 1188              	.L69:
 589:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 590:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     temp_cordic_s = ((uint32_t)1<< cordic_count);
 1189              	 .loc 2 590 0
 1190 0054 97F82F30 	 ldrb r3,[r7,#47]
 1191 0058 0122     	 movs r2,#1
 1192 005a 02FA03F3 	 lsl r3,r2,r3
 1193 005e FB61     	 str r3,[r7,#28]
 591:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     temp_cordic_scale =(int32_t)temp_cordic_s ;
 1194              	 .loc 2 591 0
 1195 0060 FB69     	 ldr r3,[r7,#28]
 1196 0062 BB61     	 str r3,[r7,#24]
 592:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     dx = cord_x / temp_cordic_scale;
 1197              	 .loc 2 592 0
 1198 0064 BA6A     	 ldr r2,[r7,#40]
 1199 0066 BB69     	 ldr r3,[r7,#24]
 1200 0068 92FBF3F3 	 sdiv r3,r2,r3
 1201 006c 7B61     	 str r3,[r7,#20]
 593:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 594:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     if (temp_angle > 0)
 1202              	 .loc 2 594 0
 1203 006e 3B6A     	 ldr r3,[r7,#32]
 1204 0070 002B     	 cmp r3,#0
 1205 0072 13DD     	 ble .L67
 595:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     {
 596:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_x -= cord_y / temp_cordic_scale;
 1206              	 .loc 2 596 0
 1207 0074 7A6A     	 ldr r2,[r7,#36]
 1208 0076 BB69     	 ldr r3,[r7,#24]
 1209 0078 92FBF3F3 	 sdiv r3,r2,r3
 1210 007c BA6A     	 ldr r2,[r7,#40]
 1211 007e D31A     	 subs r3,r2,r3
 1212 0080 BB62     	 str r3,[r7,#40]
 597:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_y += dx;
 1213              	 .loc 2 597 0
 1214 0082 7A6A     	 ldr r2,[r7,#36]
 1215 0084 7B69     	 ldr r3,[r7,#20]
 1216 0086 1344     	 add r3,r3,r2
 1217 0088 7B62     	 str r3,[r7,#36]
 598:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       temp_angle -= MOTOR_LIB_E[cordic_count];
 1218              	 .loc 2 598 0
 1219 008a 97F82F30 	 ldrb r3,[r7,#47]
 1220 008e 254A     	 ldr r2,.L72
 1221 0090 52F82330 	 ldr r3,[r2,r3,lsl#2]
 1222 0094 3A6A     	 ldr r2,[r7,#32]
 1223 0096 D31A     	 subs r3,r2,r3
 1224 0098 3B62     	 str r3,[r7,#32]
 1225 009a 12E0     	 b .L68
 1226              	.L67:
 599:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     }
 600:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     else
 601:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     {
 602:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_x += cord_y / temp_cordic_scale;
 1227              	 .loc 2 602 0
 1228 009c 7A6A     	 ldr r2,[r7,#36]
 1229 009e BB69     	 ldr r3,[r7,#24]
 1230 00a0 92FBF3F3 	 sdiv r3,r2,r3
 1231 00a4 BA6A     	 ldr r2,[r7,#40]
 1232 00a6 1344     	 add r3,r3,r2
 1233 00a8 BB62     	 str r3,[r7,#40]
 603:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       cord_y -= dx;
 1234              	 .loc 2 603 0
 1235 00aa 7A6A     	 ldr r2,[r7,#36]
 1236 00ac 7B69     	 ldr r3,[r7,#20]
 1237 00ae D31A     	 subs r3,r2,r3
 1238 00b0 7B62     	 str r3,[r7,#36]
 604:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       temp_angle += MOTOR_LIB_E[cordic_count];
 1239              	 .loc 2 604 0
 1240 00b2 97F82F30 	 ldrb r3,[r7,#47]
 1241 00b6 1B4A     	 ldr r2,.L72
 1242 00b8 52F82330 	 ldr r3,[r2,r3,lsl#2]
 1243 00bc 3A6A     	 ldr r2,[r7,#32]
 1244 00be 1344     	 add r3,r3,r2
 1245 00c0 3B62     	 str r3,[r7,#32]
 1246              	.L68:
 588:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 1247              	 .loc 2 588 0 discriminator 2
 1248 00c2 97F82F30 	 ldrb r3,[r7,#47]
 1249 00c6 0133     	 adds r3,r3,#1
 1250 00c8 87F82F30 	 strb r3,[r7,#47]
 1251              	.L66:
 588:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 1252              	 .loc 2 588 0 is_stmt 0 discriminator 1
 1253 00cc 97F82F30 	 ldrb r3,[r7,#47]
 1254 00d0 0E2B     	 cmp r3,#14
 1255 00d2 BFD9     	 bls .L69
 605:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     }
 606:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 607:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   if (flag > 0U)
 1256              	 .loc 2 607 0 is_stmt 1
 1257 00d4 97F82E30 	 ldrb r3,[r7,#46]
 1258 00d8 002B     	 cmp r3,#0
 1259 00da 02D0     	 beq .L70
 608:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 609:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     cord_y = ( -cord_y );
 1260              	 .loc 2 609 0
 1261 00dc 7B6A     	 ldr r3,[r7,#36]
 1262 00de 5B42     	 negs r3,r3
 1263 00e0 7B62     	 str r3,[r7,#36]
 1264              	.L70:
 610:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 611:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   *v_beta = (int32_t)((cord_y*MOTOR_LIB_INV_KCORDIC)/ MOTOR_LIB_MPS);
 1265              	 .loc 2 611 0
 1266 00e2 7A6A     	 ldr r2,[r7,#36]
 1267 00e4 1346     	 mov r3,r2
 1268 00e6 9B00     	 lsls r3,r3,#2
 1269 00e8 1344     	 add r3,r3,r2
 1270 00ea 5A01     	 lsls r2,r3,#5
 1271 00ec D31A     	 subs r3,r2,r3
 1272 00ee 0E4A     	 ldr r2,.L72+4
 1273 00f0 82FB0312 	 smull r1,r2,r2,r3
 1274 00f4 1A44     	 add r2,r2,r3
 1275 00f6 D211     	 asrs r2,r2,#7
 1276 00f8 DB17     	 asrs r3,r3,#31
 1277 00fa D21A     	 subs r2,r2,r3
 1278 00fc 3B68     	 ldr r3,[r7]
 1279 00fe 1A60     	 str r2,[r3]
 612:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   return ((int32_t)((cord_x*MOTOR_LIB_INV_KCORDIC)/ MOTOR_LIB_MPS));
 1280              	 .loc 2 612 0
 1281 0100 BA6A     	 ldr r2,[r7,#40]
 1282 0102 1346     	 mov r3,r2
 1283 0104 9B00     	 lsls r3,r3,#2
 1284 0106 1344     	 add r3,r3,r2
 1285 0108 5A01     	 lsls r2,r3,#5
 1286 010a D31A     	 subs r3,r2,r3
 1287 010c 064A     	 ldr r2,.L72+4
 1288 010e 82FB0312 	 smull r1,r2,r2,r3
 1289 0112 1A44     	 add r2,r2,r3
 1290 0114 D211     	 asrs r2,r2,#7
 1291 0116 DB17     	 asrs r3,r3,#31
 1292 0118 D31A     	 subs r3,r2,r3
 613:../Dave/Generated/MOTOR_LIB/motor_lib.c **** }
 1293              	 .loc 2 613 0
 1294 011a 1846     	 mov r0,r3
 1295 011c 3037     	 adds r7,r7,#48
 1296              	.LCFI49:
 1297              	 .cfi_def_cfa_offset 8
 1298 011e BD46     	 mov sp,r7
 1299              	.LCFI50:
 1300              	 .cfi_def_cfa_register 13
 1301              	 
 1302 0120 80BD     	 pop {r7,pc}
 1303              	.L73:
 1304 0122 00BF     	 .align 2
 1305              	.L72:
 1306 0124 00000000 	 .word MOTOR_LIB_E
 1307 0128 81808080 	 .word -2139062143
 1308              	 .cfi_endproc
 1309              	.LFE137:
 1311              	 .section .text.MOTOR_LIB_ClarkTransform,"ax",%progbits
 1312              	 .align 2
 1313              	 .global MOTOR_LIB_ClarkTransform
 1314              	 .thumb
 1315              	 .thumb_func
 1317              	MOTOR_LIB_ClarkTransform:
 1318              	.LFB138:
 614:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 615:../Dave/Generated/MOTOR_LIB/motor_lib.c **** #endif
 616:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**
 617:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * This function is the implementation of Clarke transform using 2 Phase current.
 618:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  */
 619:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 620:../Dave/Generated/MOTOR_LIB/motor_lib.c **** int32_t MOTOR_LIB_ClarkTransform(int32_t phase_a, int32_t phase_b, int32_t *i_alpha)
 621:../Dave/Generated/MOTOR_LIB/motor_lib.c **** {
 1319              	 .loc 2 621 0
 1320              	 .cfi_startproc
 1321              	 
 1322              	 
 1323              	 
 1324 0000 80B4     	 push {r7}
 1325              	.LCFI51:
 1326              	 .cfi_def_cfa_offset 4
 1327              	 .cfi_offset 7,-4
 1328 0002 87B0     	 sub sp,sp,#28
 1329              	.LCFI52:
 1330              	 .cfi_def_cfa_offset 32
 1331 0004 00AF     	 add r7,sp,#0
 1332              	.LCFI53:
 1333              	 .cfi_def_cfa_register 7
 1334 0006 F860     	 str r0,[r7,#12]
 1335 0008 B960     	 str r1,[r7,#8]
 1336 000a 7A60     	 str r2,[r7,#4]
 622:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   int32_t temp_scale;
 623:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   temp_scale = (int32_t)((uint32_t)1U<<15U);
 1337              	 .loc 2 623 0
 1338 000c 4FF40043 	 mov r3,#32768
 1339 0010 7B61     	 str r3,[r7,#20]
 624:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   *i_alpha  = (int32_t)(phase_a);
 1340              	 .loc 2 624 0
 1341 0012 7B68     	 ldr r3,[r7,#4]
 1342 0014 FA68     	 ldr r2,[r7,#12]
 1343 0016 1A60     	 str r2,[r3]
 625:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   return  (int32_t)(((phase_a + (2 * phase_b))*(MOTOR_LIB_INVSQRT3))/ temp_scale);
 1344              	 .loc 2 625 0
 1345 0018 BB68     	 ldr r3,[r7,#8]
 1346 001a 5A00     	 lsls r2,r3,#1
 1347 001c FB68     	 ldr r3,[r7,#12]
 1348 001e 1344     	 add r3,r3,r2
 1349 0020 44F6E612 	 movw r2,#18918
 1350 0024 02FB03F2 	 mul r2,r2,r3
 1351 0028 7B69     	 ldr r3,[r7,#20]
 1352 002a 92FBF3F3 	 sdiv r3,r2,r3
 626:../Dave/Generated/MOTOR_LIB/motor_lib.c **** }
 1353              	 .loc 2 626 0
 1354 002e 1846     	 mov r0,r3
 1355 0030 1C37     	 adds r7,r7,#28
 1356              	.LCFI54:
 1357              	 .cfi_def_cfa_offset 4
 1358 0032 BD46     	 mov sp,r7
 1359              	.LCFI55:
 1360              	 .cfi_def_cfa_register 13
 1361              	 
 1362 0034 5DF8047B 	 ldr r7,[sp],#4
 1363              	.LCFI56:
 1364              	 .cfi_restore 7
 1365              	 .cfi_def_cfa_offset 0
 1366 0038 7047     	 bx lr
 1367              	 .cfi_endproc
 1368              	.LFE138:
 1370 003a 00BF     	 .section .text.MOTOR_LIB_ClarkTransform2,"ax",%progbits
 1371              	 .align 2
 1372              	 .global MOTOR_LIB_ClarkTransform2
 1373              	 .thumb
 1374              	 .thumb_func
 1376              	MOTOR_LIB_ClarkTransform2:
 1377              	.LFB139:
 627:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**
 628:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * This function is the implementation of Clarke transform using 3 Phase current.
 629:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  */
 630:../Dave/Generated/MOTOR_LIB/motor_lib.c **** int32_t MOTOR_LIB_ClarkTransform2(int32_t phase_a, int32_t phase_b, int32_t phase_c, int32_t *i_alp
 631:../Dave/Generated/MOTOR_LIB/motor_lib.c **** {
 1378              	 .loc 2 631 0
 1379              	 .cfi_startproc
 1380              	 
 1381              	 
 1382              	 
 1383 0000 80B4     	 push {r7}
 1384              	.LCFI57:
 1385              	 .cfi_def_cfa_offset 4
 1386              	 .cfi_offset 7,-4
 1387 0002 87B0     	 sub sp,sp,#28
 1388              	.LCFI58:
 1389              	 .cfi_def_cfa_offset 32
 1390 0004 00AF     	 add r7,sp,#0
 1391              	.LCFI59:
 1392              	 .cfi_def_cfa_register 7
 1393 0006 F860     	 str r0,[r7,#12]
 1394 0008 B960     	 str r1,[r7,#8]
 1395 000a 7A60     	 str r2,[r7,#4]
 1396 000c 3B60     	 str r3,[r7]
 632:../Dave/Generated/MOTOR_LIB/motor_lib.c ****    int32_t temp_scale;
 633:../Dave/Generated/MOTOR_LIB/motor_lib.c ****    temp_scale = (int32_t)((uint32_t)1U<<15U);
 1397              	 .loc 2 633 0
 1398 000e 4FF40043 	 mov r3,#32768
 1399 0012 7B61     	 str r3,[r7,#20]
 634:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   *i_alpha  = (int32_t)(((2*phase_a)+phase_b) + phase_c);
 1400              	 .loc 2 634 0
 1401 0014 FB68     	 ldr r3,[r7,#12]
 1402 0016 5A00     	 lsls r2,r3,#1
 1403 0018 BB68     	 ldr r3,[r7,#8]
 1404 001a 1A44     	 add r2,r2,r3
 1405 001c 7B68     	 ldr r3,[r7,#4]
 1406 001e 1A44     	 add r2,r2,r3
 1407 0020 3B68     	 ldr r3,[r7]
 1408 0022 1A60     	 str r2,[r3]
 635:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   return (int32_t)(((phase_b - phase_c)*(MOTOR_LIB_INVSQRT3))/ temp_scale);
 1409              	 .loc 2 635 0
 1410 0024 BA68     	 ldr r2,[r7,#8]
 1411 0026 7B68     	 ldr r3,[r7,#4]
 1412 0028 D31A     	 subs r3,r2,r3
 1413 002a 44F6E612 	 movw r2,#18918
 1414 002e 02FB03F2 	 mul r2,r2,r3
 1415 0032 7B69     	 ldr r3,[r7,#20]
 1416 0034 92FBF3F3 	 sdiv r3,r2,r3
 636:../Dave/Generated/MOTOR_LIB/motor_lib.c **** }
 1417              	 .loc 2 636 0
 1418 0038 1846     	 mov r0,r3
 1419 003a 1C37     	 adds r7,r7,#28
 1420              	.LCFI60:
 1421              	 .cfi_def_cfa_offset 4
 1422 003c BD46     	 mov sp,r7
 1423              	.LCFI61:
 1424              	 .cfi_def_cfa_register 13
 1425              	 
 1426 003e 5DF8047B 	 ldr r7,[sp],#4
 1427              	.LCFI62:
 1428              	 .cfi_restore 7
 1429              	 .cfi_def_cfa_offset 0
 1430 0042 7047     	 bx lr
 1431              	 .cfi_endproc
 1432              	.LFE139:
 1434              	 .section .text.MOTOR_LIB_PIController,"ax",%progbits
 1435              	 .align 2
 1436              	 .global MOTOR_LIB_PIController
 1437              	 .thumb
 1438              	 .thumb_func
 1440              	MOTOR_LIB_PIController:
 1441              	.LFB140:
 637:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 638:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 639:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**
 640:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * This function is the implementation of PI controller. 
 641:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  */
 642:../Dave/Generated/MOTOR_LIB/motor_lib.c **** void MOTOR_LIB_PIController
 643:../Dave/Generated/MOTOR_LIB/motor_lib.c **** (
 644:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     MOTOR_LIB_PIHandle_t *handle_ptr,
 645:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     int32_t error_val
 646:../Dave/Generated/MOTOR_LIB/motor_lib.c **** )
 647:../Dave/Generated/MOTOR_LIB/motor_lib.c **** {
 1442              	 .loc 2 647 0
 1443              	 .cfi_startproc
 1444              	 
 1445              	 
 1446 0000 80B5     	 push {r7,lr}
 1447              	.LCFI63:
 1448              	 .cfi_def_cfa_offset 8
 1449              	 .cfi_offset 7,-8
 1450              	 .cfi_offset 14,-4
 1451 0002 84B0     	 sub sp,sp,#16
 1452              	.LCFI64:
 1453              	 .cfi_def_cfa_offset 24
 1454 0004 00AF     	 add r7,sp,#0
 1455              	.LCFI65:
 1456              	 .cfi_def_cfa_register 7
 1457 0006 7860     	 str r0,[r7,#4]
 1458 0008 3960     	 str r1,[r7]
 648:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   int32_t output;
 649:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   int32_t buf ;
 650:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /* yn(k+1)= yn(k) + ki * E(k) */
 651:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   buf = (int32_t)handle_ptr->i_buf + ((int32_t)handle_ptr->ki * error_val);
 1459              	 .loc 2 651 0
 1460 000a 7B68     	 ldr r3,[r7,#4]
 1461 000c 9A68     	 ldr r2,[r3,#8]
 1462 000e 7B68     	 ldr r3,[r7,#4]
 1463 0010 5B68     	 ldr r3,[r3,#4]
 1464 0012 1946     	 mov r1,r3
 1465 0014 3B68     	 ldr r3,[r7]
 1466 0016 03FB01F3 	 mul r3,r3,r1
 1467 001a 1344     	 add r3,r3,r2
 1468 001c FB60     	 str r3,[r7,#12]
 652:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 653:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /* Checking the buffer limits in the range of Yimin to Yimax */
 654:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   handle_ptr->i_buf = (int32_t)MOTOR_LIB_MinMaxLimiter(buf,(int32_t)(handle_ptr->y_imax),(int32_t)(
 1469              	 .loc 2 654 0
 1470 001e 7B68     	 ldr r3,[r7,#4]
 1471 0020 DA68     	 ldr r2,[r3,#12]
 1472 0022 7B68     	 ldr r3,[r7,#4]
 1473 0024 1B69     	 ldr r3,[r3,#16]
 1474 0026 F868     	 ldr r0,[r7,#12]
 1475 0028 1146     	 mov r1,r2
 1476 002a 1A46     	 mov r2,r3
 1477 002c FFF7FEFF 	 bl MOTOR_LIB_MinMaxLimiter
 1478 0030 0246     	 mov r2,r0
 1479 0032 7B68     	 ldr r3,[r7,#4]
 1480 0034 9A60     	 str r2,[r3,#8]
 655:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 656:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /* y(k+1) = yn(k+1) + kp * E(k) * 64 */
 657:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   output = (int32_t) ((int32_t)handle_ptr->kp * error_val);
 1481              	 .loc 2 657 0
 1482 0036 7B68     	 ldr r3,[r7,#4]
 1483 0038 1B68     	 ldr r3,[r3]
 1484 003a 1A46     	 mov r2,r3
 1485 003c 3B68     	 ldr r3,[r7]
 1486 003e 03FB02F3 	 mul r3,r3,r2
 1487 0042 BB60     	 str r3,[r7,#8]
 658:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 659:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   output = (handle_ptr->i_buf / MOTOR_LIB_PI_KISCALE) +(output / MOTOR_LIB_PI_KPSCALE);
 1488              	 .loc 2 659 0
 1489 0044 7B68     	 ldr r3,[r7,#4]
 1490 0046 9B68     	 ldr r3,[r3,#8]
 1491 0048 114A     	 ldr r2,.L79
 1492 004a 82FB0312 	 smull r1,r2,r2,r3
 1493 004e 1A44     	 add r2,r2,r3
 1494 0050 9213     	 asrs r2,r2,#14
 1495 0052 DB17     	 asrs r3,r3,#31
 1496 0054 D21A     	 subs r2,r2,r3
 1497 0056 BB68     	 ldr r3,[r7,#8]
 1498 0058 0E49     	 ldr r1,.L79+4
 1499 005a 81FB0301 	 smull r0,r1,r1,r3
 1500 005e 1944     	 add r1,r1,r3
 1501 0060 0912     	 asrs r1,r1,#8
 1502 0062 DB17     	 asrs r3,r3,#31
 1503 0064 CB1A     	 subs r3,r1,r3
 1504 0066 1344     	 add r3,r3,r2
 1505 0068 BB60     	 str r3,[r7,#8]
 660:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   
 661:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /* Checking the buffer limits in the range of Ymin to Ymax */
 662:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   handle_ptr->pi_out_val= (int16_t)MOTOR_LIB_MinMaxLimiter(output,(int32_t)(handle_ptr->y_max),
 1506              	 .loc 2 662 0
 1507 006a 7B68     	 ldr r3,[r7,#4]
 1508 006c 9B8A     	 ldrh r3,[r3,#20]
 1509 006e 1AB2     	 sxth r2,r3
 663:../Dave/Generated/MOTOR_LIB/motor_lib.c ****                                                                (int32_t)(handle_ptr->y_min));
 1510              	 .loc 2 663 0
 1511 0070 7B68     	 ldr r3,[r7,#4]
 1512 0072 DB8A     	 ldrh r3,[r3,#22]
 662:../Dave/Generated/MOTOR_LIB/motor_lib.c ****                                                                (int32_t)(handle_ptr->y_min));
 1513              	 .loc 2 662 0
 1514 0074 1BB2     	 sxth r3,r3
 1515 0076 B868     	 ldr r0,[r7,#8]
 1516 0078 1146     	 mov r1,r2
 1517 007a 1A46     	 mov r2,r3
 1518 007c FFF7FEFF 	 bl MOTOR_LIB_MinMaxLimiter
 1519 0080 0346     	 mov r3,r0
 1520 0082 9AB2     	 uxth r2,r3
 1521 0084 7B68     	 ldr r3,[r7,#4]
 1522 0086 1A83     	 strh r2,[r3,#24]
 664:../Dave/Generated/MOTOR_LIB/motor_lib.c **** }
 1523              	 .loc 2 664 0
 1524 0088 1037     	 adds r7,r7,#16
 1525              	.LCFI66:
 1526              	 .cfi_def_cfa_offset 8
 1527 008a BD46     	 mov sp,r7
 1528              	.LCFI67:
 1529              	 .cfi_def_cfa_register 13
 1530              	 
 1531 008c 80BD     	 pop {r7,pc}
 1532              	.L80:
 1533 008e 00BF     	 .align 2
 1534              	.L79:
 1535 0090 03000180 	 .word -2147418109
 1536 0094 11204080 	 .word -2143281135
 1537              	 .cfi_endproc
 1538              	.LFE140:
 1540              	 .section .text.MOTOR_LIB_FeedForwardController,"ax",%progbits
 1541              	 .align 2
 1542              	 .global MOTOR_LIB_FeedForwardController
 1543              	 .thumb
 1544              	 .thumb_func
 1546              	MOTOR_LIB_FeedForwardController:
 1547              	.LFB141:
 665:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 666:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**
 667:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * This function is the implementation of Feed forward controller.
 668:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  */
 669:../Dave/Generated/MOTOR_LIB/motor_lib.c **** void MOTOR_LIB_FeedForwardController( MOTOR_LIB_FeedForwardHandle_t *handle_ptr,int32_t feedforward
 670:../Dave/Generated/MOTOR_LIB/motor_lib.c **** {
 1548              	 .loc 2 670 0
 1549              	 .cfi_startproc
 1550              	 
 1551              	 
 1552 0000 80B5     	 push {r7,lr}
 1553              	.LCFI68:
 1554              	 .cfi_def_cfa_offset 8
 1555              	 .cfi_offset 7,-8
 1556              	 .cfi_offset 14,-4
 1557 0002 88B0     	 sub sp,sp,#32
 1558              	.LCFI69:
 1559              	 .cfi_def_cfa_offset 40
 1560 0004 00AF     	 add r7,sp,#0
 1561              	.LCFI70:
 1562              	 .cfi_def_cfa_register 7
 1563 0006 7860     	 str r0,[r7,#4]
 1564 0008 3960     	 str r1,[r7]
 671:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   int32_t anti_aliasing_input,derivative_out,feedforward_gain_out,limiter_out;
 672:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   uint32_t anti_aliasing_out;
 673:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   anti_aliasing_input = handle_ptr->antinoise_filter_buffer - feedforward_input_val;
 1565              	 .loc 2 673 0
 1566 000a 7B68     	 ldr r3,[r7,#4]
 1567 000c 9A68     	 ldr r2,[r3,#8]
 1568 000e 3B68     	 ldr r3,[r7]
 1569 0010 D31A     	 subs r3,r2,r3
 1570 0012 FB61     	 str r3,[r7,#28]
 674:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   anti_aliasing_out = MOTOR_LIB_abs(anti_aliasing_input);
 1571              	 .loc 2 674 0
 1572 0014 F869     	 ldr r0,[r7,#28]
 1573 0016 FFF7FEFF 	 bl MOTOR_LIB_abs
 1574 001a B861     	 str r0,[r7,#24]
 675:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 676:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /* Anti aliasing filter for system stability - ignores small variations in i/p */
 677:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   if ( anti_aliasing_out > handle_ptr->dead_band )
 1575              	 .loc 2 677 0
 1576 001c 7B68     	 ldr r3,[r7,#4]
 1577 001e 1B8C     	 ldrh r3,[r3,#32]
 1578 0020 1A46     	 mov r2,r3
 1579 0022 BB69     	 ldr r3,[r7,#24]
 1580 0024 9A42     	 cmp r2,r3
 1581 0026 38D2     	 bcs .L82
 678:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 679:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     /* storing input signal value in buffer for next cycle */
 680:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     handle_ptr->antinoise_filter_buffer = feedforward_input_val;
 1582              	 .loc 2 680 0
 1583 0028 7B68     	 ldr r3,[r7,#4]
 1584 002a 3A68     	 ldr r2,[r7]
 1585 002c 9A60     	 str r2,[r3,#8]
 681:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 682:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     /* Call PT1 low pass filter */
 683:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     MOTOR_LIB_PT1Controller(handle_ptr->pt1_filter_ptr,feedforward_input_val);
 1586              	 .loc 2 683 0
 1587 002e 7B68     	 ldr r3,[r7,#4]
 1588 0030 1B68     	 ldr r3,[r3]
 1589 0032 1846     	 mov r0,r3
 1590 0034 3968     	 ldr r1,[r7]
 1591 0036 FFF7FEFF 	 bl MOTOR_LIB_PT1Controller
 684:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 685:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     /* FeedForward gain operation */
 686:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     feedforward_gain_out  = handle_ptr->pt1_filter_ptr->pt1_out_val * (int32_t)handle_ptr->feedforw
 1592              	 .loc 2 686 0
 1593 003a 7B68     	 ldr r3,[r7,#4]
 1594 003c 1B68     	 ldr r3,[r3]
 1595 003e 5B69     	 ldr r3,[r3,#20]
 1596 0040 7A68     	 ldr r2,[r7,#4]
 1597 0042 928B     	 ldrh r2,[r2,#28]
 1598 0044 02FB03F3 	 mul r3,r2,r3
 1599 0048 7B61     	 str r3,[r7,#20]
 687:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 688:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     /* Derivative operation on input signal  */
 689:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     derivative_out = (int32_t)handle_ptr->differential_gain * ( feedforward_gain_out - handle_ptr->
 1600              	 .loc 2 689 0
 1601 004a 7B68     	 ldr r3,[r7,#4]
 1602 004c DB8B     	 ldrh r3,[r3,#30]
 1603 004e 1946     	 mov r1,r3
 1604 0050 7B68     	 ldr r3,[r7,#4]
 1605 0052 1B69     	 ldr r3,[r3,#16]
 1606 0054 7A69     	 ldr r2,[r7,#20]
 1607 0056 D31A     	 subs r3,r2,r3
 1608 0058 03FB01F3 	 mul r3,r3,r1
 1609 005c 3B61     	 str r3,[r7,#16]
 690:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     handle_ptr->differential_buffer = feedforward_gain_out;
 1610              	 .loc 2 690 0
 1611 005e 7B68     	 ldr r3,[r7,#4]
 1612 0060 7A69     	 ldr r2,[r7,#20]
 1613 0062 1A61     	 str r2,[r3,#16]
 691:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 692:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     /* FeedForward output limiter operation */
 693:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     limiter_out = MOTOR_LIB_MinMaxLimiter(derivative_out,(int32_t)handle_ptr->y_max,(int32_t)handle
 1614              	 .loc 2 693 0
 1615 0064 7B68     	 ldr r3,[r7,#4]
 1616 0066 5A69     	 ldr r2,[r3,#20]
 1617 0068 7B68     	 ldr r3,[r7,#4]
 1618 006a 9B69     	 ldr r3,[r3,#24]
 1619 006c 3869     	 ldr r0,[r7,#16]
 1620 006e 1146     	 mov r1,r2
 1621 0070 1A46     	 mov r2,r3
 1622 0072 FFF7FEFF 	 bl MOTOR_LIB_MinMaxLimiter
 1623 0076 F860     	 str r0,[r7,#12]
 694:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 695:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     /* Dead time configuration */
 696:../Dave/Generated/MOTOR_LIB/motor_lib.c ****         if (handle_ptr->dead_time_enable > 0U)
 1624              	 .loc 2 696 0
 1625 0078 7B68     	 ldr r3,[r7,#4]
 1626 007a 93F82230 	 ldrb r3,[r3,#34]
 1627 007e 002B     	 cmp r3,#0
 1628 0080 07D0     	 beq .L83
 697:../Dave/Generated/MOTOR_LIB/motor_lib.c ****         {
 698:../Dave/Generated/MOTOR_LIB/motor_lib.c ****           /* Dead time is configured store the result in buffer and send out next cycle */
 699:../Dave/Generated/MOTOR_LIB/motor_lib.c ****           handle_ptr->feedforward_out_val = handle_ptr->dead_time_buffer;
 1629              	 .loc 2 699 0
 1630 0082 7B68     	 ldr r3,[r7,#4]
 1631 0084 DA68     	 ldr r2,[r3,#12]
 1632 0086 7B68     	 ldr r3,[r7,#4]
 1633 0088 5A60     	 str r2,[r3,#4]
 700:../Dave/Generated/MOTOR_LIB/motor_lib.c ****           handle_ptr->dead_time_buffer = limiter_out;
 1634              	 .loc 2 700 0
 1635 008a 7B68     	 ldr r3,[r7,#4]
 1636 008c FA68     	 ldr r2,[r7,#12]
 1637 008e DA60     	 str r2,[r3,#12]
 1638 0090 06E0     	 b .L81
 1639              	.L83:
 701:../Dave/Generated/MOTOR_LIB/motor_lib.c ****         }
 702:../Dave/Generated/MOTOR_LIB/motor_lib.c ****         else
 703:../Dave/Generated/MOTOR_LIB/motor_lib.c ****         {
 704:../Dave/Generated/MOTOR_LIB/motor_lib.c ****           /* Delay is not configured */
 705:../Dave/Generated/MOTOR_LIB/motor_lib.c ****           handle_ptr->feedforward_out_val = limiter_out;
 1640              	 .loc 2 705 0
 1641 0092 7B68     	 ldr r3,[r7,#4]
 1642 0094 FA68     	 ldr r2,[r7,#12]
 1643 0096 5A60     	 str r2,[r3,#4]
 1644 0098 02E0     	 b .L81
 1645              	.L82:
 706:../Dave/Generated/MOTOR_LIB/motor_lib.c ****         }
 707:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 708:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   else
 709:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   {
 710:../Dave/Generated/MOTOR_LIB/motor_lib.c ****       /* FeedForward Controller output set to zero */
 711:../Dave/Generated/MOTOR_LIB/motor_lib.c ****     handle_ptr->feedforward_out_val = 0;
 1646              	 .loc 2 711 0
 1647 009a 7B68     	 ldr r3,[r7,#4]
 1648 009c 0022     	 movs r2,#0
 1649 009e 5A60     	 str r2,[r3,#4]
 1650              	.L81:
 712:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   }
 713:../Dave/Generated/MOTOR_LIB/motor_lib.c **** }
 1651              	 .loc 2 713 0
 1652 00a0 2037     	 adds r7,r7,#32
 1653              	.LCFI71:
 1654              	 .cfi_def_cfa_offset 8
 1655 00a2 BD46     	 mov sp,r7
 1656              	.LCFI72:
 1657              	 .cfi_def_cfa_register 13
 1658              	 
 1659 00a4 80BD     	 pop {r7,pc}
 1660              	 .cfi_endproc
 1661              	.LFE141:
 1663 00a6 00BF     	 .section .text.MOTOR_LIB_PT1Controller,"ax",%progbits
 1664              	 .align 2
 1665              	 .global MOTOR_LIB_PT1Controller
 1666              	 .thumb
 1667              	 .thumb_func
 1669              	MOTOR_LIB_PT1Controller:
 1670              	.LFB142:
 714:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 715:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**
 716:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * This function is the implementation of PT1 filter. 
 717:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  */
 718:../Dave/Generated/MOTOR_LIB/motor_lib.c **** void MOTOR_LIB_PT1Controller(MOTOR_LIB_PT1Handle_t *handle_ptr,int32_t actual_val)
 719:../Dave/Generated/MOTOR_LIB/motor_lib.c **** {
 1671              	 .loc 2 719 0
 1672              	 .cfi_startproc
 1673              	 
 1674              	 
 1675 0000 80B5     	 push {r7,lr}
 1676              	.LCFI73:
 1677              	 .cfi_def_cfa_offset 8
 1678              	 .cfi_offset 7,-8
 1679              	 .cfi_offset 14,-4
 1680 0002 84B0     	 sub sp,sp,#16
 1681              	.LCFI74:
 1682              	 .cfi_def_cfa_offset 24
 1683 0004 00AF     	 add r7,sp,#0
 1684              	.LCFI75:
 1685              	 .cfi_def_cfa_register 7
 1686 0006 7860     	 str r0,[r7,#4]
 1687 0008 3960     	 str r1,[r7]
 720:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   int32_t temp_buff;
 721:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /* yn+1=yn + z1*(x - yn) */
 722:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   temp_buff = handle_ptr->pt1_buf + (handle_ptr->z1*(actual_val - (handle_ptr->pt1_buf/(int32_t)MOT
 1688              	 .loc 2 722 0
 1689 000a 7B68     	 ldr r3,[r7,#4]
 1690 000c 1A69     	 ldr r2,[r3,#16]
 1691 000e 7B68     	 ldr r3,[r7,#4]
 1692 0010 1968     	 ldr r1,[r3]
 1693 0012 7B68     	 ldr r3,[r7,#4]
 1694 0014 1B69     	 ldr r3,[r3,#16]
 1695 0016 1348     	 ldr r0,.L87
 1696 0018 80FB03E0 	 smull lr,r0,r0,r3
 1697 001c 1844     	 add r0,r0,r3
 1698 001e C013     	 asrs r0,r0,#15
 1699 0020 DB17     	 asrs r3,r3,#31
 1700 0022 C31A     	 subs r3,r0,r3
 1701 0024 3868     	 ldr r0,[r7]
 1702 0026 C31A     	 subs r3,r0,r3
 1703 0028 03FB01F3 	 mul r3,r3,r1
 1704 002c 1344     	 add r3,r3,r2
 1705 002e FB60     	 str r3,[r7,#12]
 723:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /* Checking the buffer limits in the range of Ymin to Ymax */
 724:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   handle_ptr->pt1_buf = MOTOR_LIB_MinMaxLimiter(temp_buff,handle_ptr->y_max,handle_ptr->y_min);
 1706              	 .loc 2 724 0
 1707 0030 7B68     	 ldr r3,[r7,#4]
 1708 0032 9A68     	 ldr r2,[r3,#8]
 1709 0034 7B68     	 ldr r3,[r7,#4]
 1710 0036 DB68     	 ldr r3,[r3,#12]
 1711 0038 F868     	 ldr r0,[r7,#12]
 1712 003a 1146     	 mov r1,r2
 1713 003c 1A46     	 mov r2,r3
 1714 003e FFF7FEFF 	 bl MOTOR_LIB_MinMaxLimiter
 1715 0042 0246     	 mov r2,r0
 1716 0044 7B68     	 ldr r3,[r7,#4]
 1717 0046 1A61     	 str r2,[r3,#16]
 725:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   handle_ptr->pt1_out_val = (handle_ptr->pt1_buf/(int32_t)MOTOR_LIB_2POW16);
 1718              	 .loc 2 725 0
 1719 0048 7B68     	 ldr r3,[r7,#4]
 1720 004a 1B69     	 ldr r3,[r3,#16]
 1721 004c 054A     	 ldr r2,.L87
 1722 004e 82FB0312 	 smull r1,r2,r2,r3
 1723 0052 1A44     	 add r2,r2,r3
 1724 0054 D213     	 asrs r2,r2,#15
 1725 0056 DB17     	 asrs r3,r3,#31
 1726 0058 D21A     	 subs r2,r2,r3
 1727 005a 7B68     	 ldr r3,[r7,#4]
 1728 005c 5A61     	 str r2,[r3,#20]
 726:../Dave/Generated/MOTOR_LIB/motor_lib.c **** }
 1729              	 .loc 2 726 0
 1730 005e 1037     	 adds r7,r7,#16
 1731              	.LCFI76:
 1732              	 .cfi_def_cfa_offset 8
 1733 0060 BD46     	 mov sp,r7
 1734              	.LCFI77:
 1735              	 .cfi_def_cfa_register 13
 1736              	 
 1737 0062 80BD     	 pop {r7,pc}
 1738              	.L88:
 1739              	 .align 2
 1740              	.L87:
 1741 0064 01800080 	 .word -2147450879
 1742              	 .cfi_endproc
 1743              	.LFE142:
 1745              	 .section .text.MOTOR_LIB_PT12Controller,"ax",%progbits
 1746              	 .align 2
 1747              	 .global MOTOR_LIB_PT12Controller
 1748              	 .thumb
 1749              	 .thumb_func
 1751              	MOTOR_LIB_PT12Controller:
 1752              	.LFB143:
 727:../Dave/Generated/MOTOR_LIB/motor_lib.c **** /**
 728:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  * This function is the implementation of PT12 filter. 
 729:../Dave/Generated/MOTOR_LIB/motor_lib.c ****  */
 730:../Dave/Generated/MOTOR_LIB/motor_lib.c **** void MOTOR_LIB_PT12Controller(MOTOR_LIB_PT1Handle_t *handle_ptr,int32_t actual_val)
 731:../Dave/Generated/MOTOR_LIB/motor_lib.c **** { 
 1753              	 .loc 2 731 0
 1754              	 .cfi_startproc
 1755              	 
 1756              	 
 1757 0000 90B5     	 push {r4,r7,lr}
 1758              	.LCFI78:
 1759              	 .cfi_def_cfa_offset 12
 1760              	 .cfi_offset 4,-12
 1761              	 .cfi_offset 7,-8
 1762              	 .cfi_offset 14,-4
 1763 0002 85B0     	 sub sp,sp,#20
 1764              	.LCFI79:
 1765              	 .cfi_def_cfa_offset 32
 1766 0004 00AF     	 add r7,sp,#0
 1767              	.LCFI80:
 1768              	 .cfi_def_cfa_register 7
 1769 0006 7860     	 str r0,[r7,#4]
 1770 0008 3960     	 str r1,[r7]
 732:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   int32_t temp_buff;
 733:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /* yn+1=yn + z1*x - z2*yn; */
 734:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   temp_buff = handle_ptr->pt1_buf + ( (handle_ptr->z1* actual_val) -
 1771              	 .loc 2 734 0
 1772 000a 7B68     	 ldr r3,[r7,#4]
 1773 000c 1A69     	 ldr r2,[r3,#16]
 1774 000e 7B68     	 ldr r3,[r7,#4]
 1775 0010 1B68     	 ldr r3,[r3]
 1776 0012 3968     	 ldr r1,[r7]
 1777 0014 01FB03F1 	 mul r1,r1,r3
 735:../Dave/Generated/MOTOR_LIB/motor_lib.c ****                                   (handle_ptr->z2*(handle_ptr->pt1_buf/(int32_t)MOTOR_LIB_2POW16)))
 1778              	 .loc 2 735 0
 1779 0018 7B68     	 ldr r3,[r7,#4]
 1780 001a 5868     	 ldr r0,[r3,#4]
 1781 001c 7B68     	 ldr r3,[r7,#4]
 1782 001e 1B69     	 ldr r3,[r3,#16]
 1783 0020 124C     	 ldr r4,.L90
 1784 0022 84FB03E4 	 smull lr,r4,r4,r3
 1785 0026 1C44     	 add r4,r4,r3
 1786 0028 E413     	 asrs r4,r4,#15
 1787 002a DB17     	 asrs r3,r3,#31
 1788 002c E31A     	 subs r3,r4,r3
 1789 002e 03FB00F3 	 mul r3,r3,r0
 734:../Dave/Generated/MOTOR_LIB/motor_lib.c ****                                   (handle_ptr->z2*(handle_ptr->pt1_buf/(int32_t)MOTOR_LIB_2POW16)))
 1790              	 .loc 2 734 0
 1791 0032 CB1A     	 subs r3,r1,r3
 1792 0034 1344     	 add r3,r3,r2
 1793 0036 FB60     	 str r3,[r7,#12]
 736:../Dave/Generated/MOTOR_LIB/motor_lib.c ****    
 737:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   /* Checking the buffer limits in the range of Ymin to Ymax */
 738:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   handle_ptr->pt1_buf = MOTOR_LIB_MinMaxLimiter(temp_buff,handle_ptr->y_max,handle_ptr->y_min);
 1794              	 .loc 2 738 0
 1795 0038 7B68     	 ldr r3,[r7,#4]
 1796 003a 9A68     	 ldr r2,[r3,#8]
 1797 003c 7B68     	 ldr r3,[r7,#4]
 1798 003e DB68     	 ldr r3,[r3,#12]
 1799 0040 F868     	 ldr r0,[r7,#12]
 1800 0042 1146     	 mov r1,r2
 1801 0044 1A46     	 mov r2,r3
 1802 0046 FFF7FEFF 	 bl MOTOR_LIB_MinMaxLimiter
 1803 004a 0246     	 mov r2,r0
 1804 004c 7B68     	 ldr r3,[r7,#4]
 1805 004e 1A61     	 str r2,[r3,#16]
 739:../Dave/Generated/MOTOR_LIB/motor_lib.c **** 
 740:../Dave/Generated/MOTOR_LIB/motor_lib.c ****   handle_ptr->pt1_out_val = (handle_ptr->pt1_buf/(int32_t)MOTOR_LIB_2POW16);
 1806              	 .loc 2 740 0
 1807 0050 7B68     	 ldr r3,[r7,#4]
 1808 0052 1B69     	 ldr r3,[r3,#16]
 1809 0054 054A     	 ldr r2,.L90
 1810 0056 82FB0312 	 smull r1,r2,r2,r3
 1811 005a 1A44     	 add r2,r2,r3
 1812 005c D213     	 asrs r2,r2,#15
 1813 005e DB17     	 asrs r3,r3,#31
 1814 0060 D21A     	 subs r2,r2,r3
 1815 0062 7B68     	 ldr r3,[r7,#4]
 1816 0064 5A61     	 str r2,[r3,#20]
 741:../Dave/Generated/MOTOR_LIB/motor_lib.c **** } 
 1817              	 .loc 2 741 0
 1818 0066 1437     	 adds r7,r7,#20
 1819              	.LCFI81:
 1820              	 .cfi_def_cfa_offset 12
 1821 0068 BD46     	 mov sp,r7
 1822              	.LCFI82:
 1823              	 .cfi_def_cfa_register 13
 1824              	 
 1825 006a 90BD     	 pop {r4,r7,pc}
 1826              	.L91:
 1827              	 .align 2
 1828              	.L90:
 1829 006c 01800080 	 .word -2147450879
 1830              	 .cfi_endproc
 1831              	.LFE143:
 1833              	 .text
 1834              	.Letext0:
 1835              	 .file 3 "c:\\davev4-64bit\\dave-4.3.2\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 1836              	 .file 4 "c:\\davev4-64bit\\dave-4.3.2\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 1837              	 .file 5 "C:/Users/Mafish/Documents/XMCDev/Silniki2_0/Dave/Generated/DAVE_common.h"
 1838              	 .file 6 "C:/Users/Mafish/Documents/XMCDev/Silniki2_0/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 motor_lib.c
    {standard input}:20     .text.MOTOR_LIB_MinMaxLimiter:00000000 $t
    {standard input}:24     .text.MOTOR_LIB_MinMaxLimiter:00000000 MOTOR_LIB_MinMaxLimiter
    {standard input}:89     .text.MOTOR_LIB_abs:00000000 $t
    {standard input}:93     .text.MOTOR_LIB_abs:00000000 MOTOR_LIB_abs
    {standard input}:149    .rodata.MOTOR_LIB_E:00000000 MOTOR_LIB_E
    {standard input}:146    .rodata.MOTOR_LIB_E:00000000 $d
    {standard input}:174    .text.MOTOR_LIB_GetAppVersion:00000000 $t
    {standard input}:179    .text.MOTOR_LIB_GetAppVersion:00000000 MOTOR_LIB_GetAppVersion
    {standard input}:240    .text.MOTOR_LIB_Car2Pol:00000000 $t
    {standard input}:245    .text.MOTOR_LIB_Car2Pol:00000000 MOTOR_LIB_Car2Pol
    {standard input}:422    .text.MOTOR_LIB_Car2Pol:00000118 $d
    {standard input}:429    .text.MOTOR_LIB_ResultantMagnitudeCircular:00000000 $t
    {standard input}:434    .text.MOTOR_LIB_ResultantMagnitudeCircular:00000000 MOTOR_LIB_ResultantMagnitudeCircular
    {standard input}:558    .text.MOTOR_LIB_ResultantMagnitudeCircular:000000b0 $d
    {standard input}:563    .text.MOTOR_LIB_ResultantMagnitudeHyperbolic:00000000 $t
    {standard input}:568    .text.MOTOR_LIB_ResultantMagnitudeHyperbolic:00000000 MOTOR_LIB_ResultantMagnitudeHyperbolic
    {standard input}:744    .text.MOTOR_LIB_ResultantMagnitudeHyperbolic:0000010c $d
    {standard input}:749    .text.MOTOR_LIB_Pol2Car:00000000 $t
    {standard input}:754    .text.MOTOR_LIB_Pol2Car:00000000 MOTOR_LIB_Pol2Car
    {standard input}:932    .text.MOTOR_LIB_Pol2Car:00000124 $d
    {standard input}:938    .text.MOTOR_LIB_ParkTransform:00000000 $t
    {standard input}:943    .text.MOTOR_LIB_ParkTransform:00000000 MOTOR_LIB_ParkTransform
    {standard input}:1119   .text.MOTOR_LIB_ParkTransform:00000124 $d
    {standard input}:1125   .text.MOTOR_LIB_IParkTransform:00000000 $t
    {standard input}:1130   .text.MOTOR_LIB_IParkTransform:00000000 MOTOR_LIB_IParkTransform
    {standard input}:1306   .text.MOTOR_LIB_IParkTransform:00000124 $d
    {standard input}:1312   .text.MOTOR_LIB_ClarkTransform:00000000 $t
    {standard input}:1317   .text.MOTOR_LIB_ClarkTransform:00000000 MOTOR_LIB_ClarkTransform
    {standard input}:1371   .text.MOTOR_LIB_ClarkTransform2:00000000 $t
    {standard input}:1376   .text.MOTOR_LIB_ClarkTransform2:00000000 MOTOR_LIB_ClarkTransform2
    {standard input}:1435   .text.MOTOR_LIB_PIController:00000000 $t
    {standard input}:1440   .text.MOTOR_LIB_PIController:00000000 MOTOR_LIB_PIController
    {standard input}:1535   .text.MOTOR_LIB_PIController:00000090 $d
    {standard input}:1541   .text.MOTOR_LIB_FeedForwardController:00000000 $t
    {standard input}:1546   .text.MOTOR_LIB_FeedForwardController:00000000 MOTOR_LIB_FeedForwardController
    {standard input}:1669   .text.MOTOR_LIB_PT1Controller:00000000 MOTOR_LIB_PT1Controller
    {standard input}:1664   .text.MOTOR_LIB_PT1Controller:00000000 $t
    {standard input}:1741   .text.MOTOR_LIB_PT1Controller:00000064 $d
    {standard input}:1746   .text.MOTOR_LIB_PT12Controller:00000000 $t
    {standard input}:1751   .text.MOTOR_LIB_PT12Controller:00000000 MOTOR_LIB_PT12Controller
    {standard input}:1829   .text.MOTOR_LIB_PT12Controller:0000006c $d
                     .debug_frame:00000010 $d

NO UNDEFINED SYMBOLS
